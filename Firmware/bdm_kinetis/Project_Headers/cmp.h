/**
 * @file     cmp.h
 * @brief    Voltage Comparator
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */

#ifndef PROJECT_HEADERS_CMP_H_
#define PROJECT_HEADERS_CMP_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "hardware.h"

namespace USBDM {
/**
 * @addtogroup CMP_Group CMP, Analogue Comparator
 * @brief Pins used for Analogue Comparator
 * @{
 */

/**
 * Type definition for CMP interrupt call back
 *
 * @param status Flags indicating interrupt source (CMP_SCR_CFR_MASK, CMP_SCR_CFF_MASK)
 */
typedef void (*CMPCallbackFunction)(int status);

/**
 * Template class representing a Voltage Reference
 *
 * @tparam info      Information class for CMP
 *
 * @code
 * using cmp = CmpIrq_T<CmpInfo>;
 *
 *  cmp::initialise();
 *
 * @endcode
 */
template<class Info>
class CmpBase_T {

protected:
   static constexpr volatile CMP_Type *cmp      = Info::cmp;
   static constexpr volatile uint32_t *clockReg = Info::clockReg;

public:
   /**
    * Enable the voltage reference with default settings
    */
   static void enable() {
      // Configure pins
      Info::initPCRs();

      // Enable clock to CMP interface
      *clockReg |= Info::clockMask;

      // Initialise hardware
      cmp->CR0   = Info::cr0;
      cmp->CR1   = Info::cr1 | CMP_CR1_EN_MASK;
      cmp->FPR   = Info::fpr;
      cmp->SCR   = Info::scr;
      cmp->DACCR = Info::daccr;
      cmp->MUXCR = Info::muxcr;

      enableNvicInterrupts();
   }

   /**
    * Disable Cmp
    */
   static void disable() {
      cmp->CR1 = 0;
      *clockReg &= ~Info::clockMask;
   }

   /**
    * Enable/disable interrupts in NVIC
    *
    * @param enable true to enable, false to disable
    */
   static void enableNvicInterrupts(bool enable=true) {

      if (enable) {
         // Enable interrupts
         NVIC_EnableIRQ(Info::irqNums[0]);

         // Set priority level
         NVIC_SetPriority(Info::irqNums[0], Info::irqLevel);
      }
      else {
         // Disable interrupts
         NVIC_DisableIRQ(Info::irqNums[0]);
      }
   }

   /**
    * Enable/disable rising edge interrupts
    *
    * @param enable True=>enable, False=>disable
    */
   static void enableRisingEdgeInterrupts(bool enable=true) {
      if (enable) {
         cmp->SCR |= CMP_SCR_IER_MASK;
      }
      else {
         cmp->SCR &= ~CMP_SCR_IER_MASK;
      }
   }
   /**
    * Enable/disable falling edge interrupts
    *
    * @param enable True=>enable, False=>disable
    */
   static void enableFallingEdgeInterrupts(bool enable=true) {
      if (enable) {
         cmp->SCR |= CMP_SCR_IEF_MASK;
      }
      else {
         cmp->SCR &= ~CMP_SCR_IEF_MASK;
      }
   }

   /**
    * Configure DAC
    *
    * @param level  DAC level to select (0..63)
    * @param source Reference source select (0..1) Usually 0=>Vin, 1=>Vdd
    * @param enable True=>enable, False=>disable
    */
   static void setDacLevel(uint8_t level, uint8_t source=1, bool enable=true) {
      cmp->DACCR = CMP_DACCR_DACEN(enable)|CMP_DACCR_VRSEL(source)|CMP_DACCR_VOSEL(level);
   }

   /**
    * Configure Comparator input sources
    *
    * @param positiveSource (0..7) (7 => DAC)
    * @param negativeSource (0..7) (7 => DAC)
    */
   static void selectInputs(uint8_t positiveSource, uint8_t negativeSource) {
      //! MUX Control Register
      cmp->MUXCR =
         CMP_MUXCR_PSEL(positiveSource)| // Plus Input Mux Control
         CMP_MUXCR_MSEL(negativeSource); // Minus Input Mux Control
   }

};

/**
 * Template class to provide CMP callback
 */
template<class Info>
class CmpIrq_T : public CmpBase_T<Info> {

protected:
   /** Callback function for ISR */
   static CMPCallbackFunction callback;

public:
   /**
    * IRQ handler
    */
   static void irqHandler() {
      int status = CmpBase_T<Info>::cmp->SCR&(CMP_SCR_CFR_MASK|CMP_SCR_CFF_MASK);
      // Clear interrupt
      CmpBase_T<Info>::cmp->SCR |= status;
      if (callback != 0) {
         callback(status);
      }
      else {
         setAndCheckErrorCode(E_NO_HANDLER);
      }
   }

   /**
    * Set callback function
    *
    * @param theCallback Callback function to execute on interrupt
    */
   static void setCallback(CMPCallbackFunction theCallback) {
      callback = theCallback;
   }
};

template<class Info> CMPCallbackFunction CmpIrq_T<Info>::callback = 0;

#if defined(USBDM_CMP_IS_DEFINED)
using Cmp = CmpIrq_T<CmpInfo>;
#endif

#if defined(USBDM_CMP0_IS_DEFINED)
using Cmp0 = CmpIrq_T<Cmp0Info>;
#endif

#if defined(USBDM_CMP1_IS_DEFINED)
using Cmp1 = CmpIrq_T<Cmp1Info>;
#endif

#if defined(USBDM_CMP2_IS_DEFINED)
using Cmp2 = CmpIrq_T<Cmp2Info>;
#endif

#if defined(USBDM_CMP3_IS_DEFINED)
using Cmp3 = CmpIrq_T<Cmp3Info>;
#endif
/**
 * @}
 */
} // End namespace USBDM

#endif /* PROJECT_HEADERS_CMP_H_ */
