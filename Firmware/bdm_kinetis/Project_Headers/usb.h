/*
 * usb.h
 *
 *  Created on: 25/10/2013
 *      Author: podonoghue
 */

#ifndef USB_H_
#define USB_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "hardware.h"

namespace USBDM {

/**
 * Type definition for USB interrupt call back
 *
 *  @param status Interrupt status e.g. USB_ISTAT_SOFTOK_MASK, USB_ISTAT_STALL_MASK etc
 */
typedef void (*USBCallbackFunction)(uint8_t status);

template <class Info>
class UsbBase_T {

protected:
   static constexpr volatile USB_Type *usb      = Info::usb;
   static constexpr volatile uint32_t *clockReg = Info::clockReg;

public:
   /**
    * Initialise USB to default settings\n
    * Configures all USB pins
    */
   static void enable() {
      *clockReg |= Info::clockMask;
      __DMB();

      Info::initPCRs();

      enableNvicInterrupts();
   }

   /**
    * Enable/disable interrupts in NVIC
    *
    * @param enable true to enable, false to disable
    */
   static void enableNvicInterrupts(bool enable=true) {

      if (enable) {
         // Enable interrupts
         NVIC_EnableIRQ(Info::irqNums[0]);

         // Set priority level
         NVIC_SetPriority(Info::irqNums[0], Info::irqLevel);
      }
      else {
         // Disable interrupts
         NVIC_DisableIRQ(Info::irqNums[0]);
      }
   }

   /**
    * Enable/disable interrupts
    *
    * @param mask Mask of interrupts to enable e.g. USB_INTEN_SOFTOKEN_MASK, USB_INTEN_STALLEN_MASK etc
    */
   static void enableInterrupts(uint8_t mask=0xFF) {
      usb->INTEN = mask;
   }

   /**
    * Enable/disable OTG interrupts
    *
    * @param mask Mask of interrupts to enable e.g. USB_OTGICR_IDEN_MASK, USB_OTGICR_ONEMSECEN_MASK etc
    */
   static void enableOtgInterrupts(uint8_t mask=0xFF) {
      usb->OTGICR = mask;
   }

};

#ifdef USBDM_USB0_IS_DEFINED
/**
 * Class representing USB
 */
class Usb0 : public UsbBase_T<Usb0Info> {

private:
   static void handleTokenComplete();
   /**
    * Handler for USB Bus reset\n
    * Re-initialises the interface
    */
   static void handleUSBReset();
   /**
    * STALL completed - re-enable ep0 for SETUP
    */
   static void handleStallComplete();
   /**
    * Handler for Start of Frame Token interrupt (~1ms interval)
    */
   static void handleSOFToken();
   /*
    * Handler for USB Suspend
    *   - Enables the USB module to wake-up the CPU
    *   - Stops the CPU
    * On wake-up
    *   - Re-checks the USB after a small delay to avoid wake-ups by noise
    *   - The RESUME interrupt is left pending so the resume handler can execute
    */
   static void handleUSBSuspend();
   /**
    * Handler for USB Resume
    *
    * Disables further USB module wakeups
    */
   static void handleUSBResume();

public:

   /**
    * Initialise the USB interaface
    */
   static void initialise();
   /**
    * Handler for USB interrupt
    *
    * Determines source and dispatches to appropriate routine.
    */
   static void irqHandler(void);
};

#endif

} // End namespace USBDM

#endif /* USB_H_ */
