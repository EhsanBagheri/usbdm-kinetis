/*
 * tsi.h
 *
 *  Created on: 25/10/2013
 *      Author: podonoghue
 */

#ifndef TSI_H_
#define TSI_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "hardware.h"

namespace USBDM {

/**
 * Type definition for TSI interrupt call back
 *
 *  @param status - Interrupt flags e.g. TSI_GENCS_EOSF_MASK, TSI_GENCS_OVRF_MASK, TSI_GENCS_EXTERF_MASK
 */
typedef void (*TSICallbackFunction)(uint8_t status);

template <class Info>
class TsiBase_T {

protected:
   static constexpr volatile TSI_Type *tsi      = Info::tsi;
   static constexpr volatile uint32_t *clockReg = Info::clockReg;

public:
   /**
    * Initialise TSI to default settings\n
    * Configures all TSI pins
    */
   static void enable() {
      *clockReg |= Info::clockMask;
      __DMB();

      Info::initPCRs();

      tsi->GENCS     = Info::tsi_gencs|TSI_GENCS_TSIEN_MASK;
      tsi->SCANC     = Info::tsi_scanc;
      tsi->THRESHOLD = Info::tsi_threshold;
      tsi->PEN       = Info::tsi_pen;

      enableNvicInterrupts();
   }

   /**
    * Enable/disable interrupts in NVIC
    *
    * @param enable True => enable, False => disable
    */
   static void enableNvicInterrupts(bool enable=true) {
      if (enable) {
         // Enable interrupts
         NVIC_EnableIRQ(Info::irqNums[0]);

         // Set priority level
         NVIC_SetPriority(Info::irqNums[0], Info::irqLevel);
      }
      else {
         // Disable interrupts
         NVIC_DisableIRQ(Info::irqNums[0]);
      }
   }
   /**
    * Enable/disable error interrupts
    *
    * @param enable True => enable, False => disable
    */
   static void enableErrorInterrupts(bool enable=true) {
      if (enable) {
         tsi->GENCS |= TSI_GENCS_ERIE_MASK;
      }
      else {
         tsi->GENCS &= ~TSI_GENCS_ERIE_MASK;
      }
   }
   /**
    * Enable/disable touch sensing interrupts
    *
    * @param enable True => enable, False => disable
    */
   static void enableTsiInterrupts(bool enable=true) {
      if (enable) {
         tsi->GENCS |= TSI_GENCS_TSIIE_MASK;
      }
      else {
         tsi->GENCS &= ~TSI_GENCS_TSIIE_MASK;
      }
   }

   /**
    * Get channel count value
    *
    * @param channel Channel number
    *
    * @return 16-bit count value
    */
   static uint16_t getCount(int channel) {
      return Info::tsi->CNTR[channel];
   }

   /**
    * Start configured scan
    */
   static void startScan() {
      // Clear flags and start scan
      Info::tsi->GENCS |= TSI_GENCS_SWTS_MASK|TSI_GENCS_EOSF_MASK|TSI_GENCS_OUTRGF_MASK|TSI_GENCS_EXTERF_MASK|TSI_GENCS_OVRF_MASK;
   }

   /**
    * Start configured scan and wait for completion
    */
   static ErrorCode startScanAndWait() {
      // Clear flags and start scan
      Info::tsi->GENCS |= TSI_GENCS_SWTS_MASK|TSI_GENCS_EOSF_MASK|TSI_GENCS_OUTRGF_MASK|TSI_GENCS_EXTERF_MASK|TSI_GENCS_OVRF_MASK;

      // Wait for complete flag or err
      while ((Info::tsi->GENCS&(TSI_GENCS_EOSF_MASK|TSI_GENCS_OUTRGF_MASK|TSI_GENCS_EXTERF_MASK|TSI_GENCS_OVRF_MASK)) == 0) {
      }

      return (Info::tsi->GENCS&(TSI_GENCS_OUTRGF_MASK|TSI_GENCS_EXTERF_MASK|TSI_GENCS_OVRF_MASK))?E_ERROR:E_NO_ERROR;
   }
};

/**
 * Template class to provide TSI callback
 */
template<class Info>
class TsiIrq_T : public TsiBase_T<Info> {

protected:
   /** Callback function for ISR */
   static TSICallbackFunction callback;

public:
   /**
    * IRQ handler
    */
   static void irqHandler(void) {
      uint8_t status = TsiBase_T<Info>::tsi->GENCS&(TSI_GENCS_EOSF_MASK|TSI_GENCS_OVRF_MASK|TSI_GENCS_EXTERF_MASK);
      if (callback != 0) {
         TsiBase_T<Info>::tsi->GENCS |= status;
         callback(status);
      }
   }

   /**
    * Set Callback function
    *
    *   @param theCallback - Callback function to be executed on TSI alarm interrupt
    */
   static void setCallback(TSICallbackFunction theCallback) {
      callback = theCallback;
   }
};

template<class Info> TSICallbackFunction TsiIrq_T<Info>::callback = 0;

#ifdef USBDM_TSI_IS_DEFINED
/**
 * Class representing TSI
 */
using Tsi = TsiIrq_T<TsiInfo>;

#endif

#ifdef USBDM_TSI0_IS_DEFINED
/**
 * Class representing TSI
 */
using Tsi0 = TsiIrq_T<Tsi0Info>;

#endif

} // End namespace USBDM

#endif /* TSI_H_ */
