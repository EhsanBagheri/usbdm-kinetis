/**
 * @file      pin_mapping.h (derived from MK22F51212.usbdmHardware)
 * @version   1.2.0
 * @brief     Pin declarations for MK22FN512VLH12
 *
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#ifndef PROJECT_HEADERS_PIN_MAPPING_H
#define PROJECT_HEADERS_PIN_MAPPING_H

#include <stddef.h>
#include "derivative.h"

#include "pcr.h"

/**
 * Namespace enclosing USBDM classes
 */
namespace USBDM {

/**
 * @addtogroup USBDM_Group USBDM Peripheral Interface
 * @brief Hardware Peripheral Interface and library
 * @{
 */
/* Template:_common_settings.xml */

#if defined(PCC)

/** Dummy port information for pins without an associated PCR */
constexpr PortInfo  __attribute__((unused)) NoPortInfo {0, 0, (IRQn_Type)-1};

#if defined(PCC_PCC_PORTA_CGC_MASK)
/** Port information for PORTA*/
constexpr PortInfo  __attribute__((unused)) PortAInfo {PORTA_BasePtr, (uint32_t)(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTA)), PORTA_IRQn};
#endif

#if defined(PCC_PCC_PORTB_CGC_MASK)
/** Port information for PORTB*/
constexpr PortInfo  __attribute__((unused)) PortBInfo {PORTB_BasePtr, (uint32_t)(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTB)), PORTB_IRQn};
#endif

#if defined(PCC_PCC_PORTC_CGC_MASK)
/** Port information for PORTC*/
constexpr PortInfo  __attribute__((unused)) PortCInfo {PORTC_BasePtr, (uint32_t)(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTC)), PORTC_IRQn};
#endif

#if defined(PCC_PCC_PORTD_CGC_MASK)
/** Port information for PORTD*/
constexpr PortInfo  __attribute__((unused)) PortDInfo {PORTD_BasePtr, (uint32_t)(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTD)), PORTD_IRQn};
#endif

#if defined(PCC_PCC_PORTE_CGC_MASK)
/** Port information for PORTE*/
constexpr PortInfo  __attribute__((unused)) PortEInfo {PORTE_BasePtr, (uint32_t)(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTE)), PORTE_IRQn};
#endif

#if defined(PCC_PCC_PORTF_CGC_MASK)
/** Port information for PORTF*/
constexpr PortInfo  __attribute__((unused)) PortFInfo {PORTF_BasePtr, (uint32_t)(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTF)), PORTF_IRQn};
#endif

#if defined(PCC_PCC_PORTG_CGC_MASK)
/** Port information for PORTG*/
constexpr PortInfo  __attribute__((unused)) PortGInfo {PORTG_BasePtr, (uint32_t)(PCC_BasePtr+offsetof(PCC_Type, PCC_PORTG)), PORTG_IRQn};
#endif

#else // defined(PCC)
/** Dummy port information for pins without an associated PCR */
constexpr PortInfo  __attribute__((unused)) NoPortInfo {0, 0, (IRQn_Type)-1};

#ifdef SIM_SCGC5_PORTA_MASK
/** Port information for PORTA */
constexpr PortInfo  __attribute__((unused)) PortAInfo {PORTA_BasePtr, SIM_SCGC5_PORTA_MASK, PORTA_IRQn};
#endif

#ifdef SIM_SCGC5_PORTB_MASK
/** Port information for PORTB */
constexpr PortInfo  __attribute__((unused)) PortBInfo {PORTB_BasePtr, SIM_SCGC5_PORTB_MASK, PORTB_IRQn};
#endif

#ifdef SIM_SCGC5_PORTC_MASK
/** Port information for PORTC */
constexpr PortInfo  __attribute__((unused)) PortCInfo {PORTC_BasePtr, SIM_SCGC5_PORTC_MASK, PORTC_IRQn};
#endif

#ifdef SIM_SCGC5_PORTD_MASK
/** Port information for PORTD */
constexpr PortInfo  __attribute__((unused)) PortDInfo {PORTD_BasePtr, SIM_SCGC5_PORTD_MASK, PORTD_IRQn};
#endif

#ifdef SIM_SCGC5_PORTE_MASK
/** Port information for PORTE */
constexpr PortInfo  __attribute__((unused)) PortEInfo {PORTE_BasePtr, SIM_SCGC5_PORTE_MASK, PORTE_IRQn};
#endif

#endif // defined(PCC)

/** Class to static check signal mapping is valid */
template<class Info, int signalNum> class CheckSignal {
   static_assert((signalNum<Info::numSignals), "Non-existent signal - Modify Configure.usbdm");
   static_assert((signalNum>=Info::numSignals)||(Info::info[signalNum].gpioBit != UNMAPPED_PCR), "Signal is not mapped to a pin - Modify Configure.usbdm");
   static_assert((signalNum>=Info::numSignals)||(Info::info[signalNum].gpioBit != INVALID_PCR),  "Signal doesn't exist in this device/package");
   static_assert((signalNum>=Info::numSignals)||((Info::info[signalNum].gpioBit == UNMAPPED_PCR)||(Info::info[signalNum].gpioBit == INVALID_PCR)||(Info::info[signalNum].gpioBit >= 0)), "Illegal signal");
};

/** Enables mapping of all allocated pins during startup using mapAllPins() */
static constexpr bool MAP_ALL_PINS = false;

/** Used to configure pin-mapping before 1st use of peripherals */
extern void mapAllPins();

/* END Template:_common_settings.xml */

/*
 * Peripheral Information Classes
 */
/**
 * @addtogroup OSC_Group OSC, Crystal Oscillator
 * @brief Abstraction for Crystal Oscillator
 * @{
 */
#define USBDM_OSC0_IS_DEFINED
/**
 * Peripheral information for OSC, Crystal Oscillator.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Osc0Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = OSC0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile OSC_Type &osc() {
      return *(OSC_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:osc0_div

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   //! Frequency of OSC Clock or Crystal
   static constexpr uint32_t osc_clock = 0UL;

   //! Frequency of 32K OSC Clock or Crystal (if applicable)
   static constexpr uint32_t osc32k_clock = 0UL;

   //! Oscillator control register
   static constexpr uint32_t cr =
      OSC_CR_ERCLKEN(1)  | // External Reference Enable
      OSC_CR_EREFSTEN(0) | // External Reference Stop Enable
      OSC_CR_SCP(0);       // Oscillator load capacitance

   //! OSC Clock divider register
   static constexpr uint32_t div =
      OSC_DIV_ERPS(0);   // ERCLK prescaler

   /**
    * Get OSC clock (internal, assumed available)
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static constexpr uint32_t getOscClock() {
      return osc_clock;
   }

   /**
    * Get OSC clock (external, gated by OSC_CR_ERCLKEN)
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static uint32_t getOscerClock() {
      return (osc().CR&OSC_CR_ERCLKEN_MASK)?
         (osc_clock/(1<<((osc().DIV&OSC_DIV_ERPS_MASK)>>OSC_DIV_ERPS_SHIFT))):
         0;
   }

   /**
    * Get OSC32KCLK clock
    *
    * @return Clock frequency as uint32_t in Hz

    * @note This clock is only available if a 32kHz crystal or external clock is used
    */
   static uint32_t getOsc32kClock() {
      return osc32k_clock;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: XTAL0                = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: EXTAL0               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/**
 * End group OSC_Group
 * @}
 */
/**
 * @addtogroup RTC_Group RTC, Real Time Clock
 * @brief Abstraction for Real Time Clock
 * @{
 */
#define USBDM_RTC_IS_DEFINED
/**
 * Peripheral information for RTC, Real Time Clock.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class RtcInfo {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = RTC_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile RTC_Type &rtc() {
      return *(RTC_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      RTC_Alarm_IRQn, RTC_Seconds_IRQn, };

   // Template:rtc_mk22f12810

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Frequency of RTC External Clock or Crystal
   static constexpr uint32_t osc_input_freq = 32768UL;

   //! Oscillator control register
   static constexpr uint32_t cr =
      RTC_CR_OSCE(0) | // Enables 32kHz oscillator [RTC_32K]
      RTC_CR_CLKO(0) | // Disables RTC 32kHz Clock Output
      RTC_CR_UM(0)   | // Update Mode
      RTC_CR_SUP(0)  | // Supervisor access
      RTC_CR_WPE(0)  | // Wakeup Pin Enable
      RTC_CR_SCP(0);   // RTC Oscillator load capacitance

   //! RTC Time Compensation Register
   static constexpr uint32_t tcr =
      RTC_TCR_CIR(0) | // Compensation Interval Register
      RTC_TCR_TCR(0);  // Time Compensation Register

   //! RTC Lock Register
   static constexpr uint32_t lr =
      RTC_LR_LRL(1) | // Lock Register Lock
      RTC_LR_SRL(1) | // Status Register Lock
      RTC_LR_CRL(1) | // Control Register Lock
      RTC_LR_TCL(1);  // Time Compensation Lock

   #if defined(RTC_WAR_TSRW)
   //! RTC Write Access Register
   static constexpr uint32_t war =
      RTC_WAR_IERW(1) | // Interrupt Enable Register Write
      RTC_WAR_LRW(1)  | // Lock Register Write
      RTC_WAR_SRW(1)  | // Status Register Write
      RTC_WAR_CRW(1)  | // Control Register Write
      RTC_WAR_TCRW(1) | // Time Compensation Register Write
      RTC_WAR_TARW(1) | // Time Alarm Register Write
      RTC_WAR_TPRW(1) | // Time Prescaler Register Write
      RTC_WAR_TSRW(1);  // Time Seconds Register Write
   #endif

   #if defined(RTC_RAR_TSRR)
   //! RTC Read Access Register
   static constexpr uint32_t rar =
      RTC_RAR_IERR(1) | // Interrupt Enable Register Read
      RTC_RAR_LRR(1)  | // Lock Register Read
      RTC_RAR_SRR(1)  | // Status Register Read
      RTC_RAR_CRR(1)  | // Control Register Read
      RTC_RAR_TCRR(1) | // Time Compensation Register Read
      RTC_RAR_TARR(1) | // Time Alarm Register Read
      RTC_RAR_TPRR(1) | // Time Prescaler Register Read
      RTC_RAR_TSRR(1);  // Time Seconds Register Read
   #endif

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   //! Time for cold start (corrected for 12 leap years since 1970)
   static constexpr uint32_t coldStartTime =
            ((((2017-1970)*365UL +
               (181) +
               (1+12-1))*24 +
              (12))*60 +
             (0))*60;

   /**
    *  Enable clock to Rtc
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableRtcClock();
#else
      SIM->SCGC6 |= SIM_SCGC6_RTC_MASK;
#endif
   }

   /**
    *  Disable clock to Rtc
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableRtcClock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_RTC_MASK;
#endif
   }

   /**
    * Get RTC clock frequency (internal, not masked by RTC_CR_CLKO)
    *
    * @return Clock frequency as uint32_t
    */
   static uint32_t getInternalClock() {
      // RTC uses EXTAL32/XTAL32 clock
      return (rtc().CR&RTC_CR_OSCE_MASK)?osc_input_freq:0;
   }

   /**
    * Get RTC clock frequency (external, masked by RTC_CR_CLKO)
    *
    * @return Clock frequency as uint32_t
    */
   static uint32_t getExternalClock() {
      return (rtc().CR&RTC_CR_CLKO_MASK)?0:getInternalClock();
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 5;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: XTAL32               = XTAL32 (p19)                   */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*   1: EXTAL32              = EXTAL32 (p20)                  */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*   2: RTC_CLKOUT           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   4: RTC_WAKEUP_b         = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/**
 * End group RTC_Group
 * @}
 */
/**
 * @addtogroup MCG_Group MCG, Multipurpose Clock Generator
 * @brief Abstraction for Multipurpose Clock Generator
 * @{
 */
#define USBDM_MCG_IS_DEFINED
/**
 * Peripheral information for MCG, Multipurpose Clock Generator.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class McgInfo {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = MCG_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile MCG_Type &mcg() {
      return *(MCG_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      MCG_IRQn, };

   // Template:mcg_mk_ics48m

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   //! Not present on these devices
   static constexpr int ERRATA_E2448 = 0;

   enum ClockMode {
      ClockMode_None     = -1,
      ClockMode_FEI      = 0,
      ClockMode_FEE,
      ClockMode_FBI,
      ClockMode_BLPI,
      ClockMode_FBE,
      ClockMode_BLPE,
      ClockMode_PBE,
      ClockMode_PEE,
   };

   //! Frequency of Internal 48MHz Clock
   static constexpr uint32_t irc48m_clock = 48000000UL;

   //! Frequency of Slow Internal Reference Clock [~32kHz]
   static constexpr uint32_t system_slow_irc_clock = 32768UL;

   //! Frequency of Fast Internal Reference Clock [~4MHz]
   static constexpr uint32_t system_fast_irc_clock = 4000000UL;

   //! PLL VDIV min value
   static constexpr uint32_t pll_vdiv_min = 24;

   //! PLL post divider
   static constexpr uint32_t pll_post_divider = 1;

   //! Structure for clock configurations
   struct ClockInfo {
      //! System Clock Divider Register 1
      const uint32_t clkdiv1;

   #ifdef SIM_CLKDIV3_PLLFLLDIV
      //! PLLFLL clock divider divisor & fraction
      const uint32_t clkdiv3;
   #endif

      //! SIM SOPT2 - Clock selectors for various peripherals
      const uint32_t sopt2;

      //! Clock Mode
      const ClockMode clockMode:8;

      //! Control Register 1 - FRDIV, IRCLKEN, IREFSTEN, (-CLKS, -IREFS)
      const uint8_t c1;
      //! Control Register 2 - LOCRE0, RANGE0, HGO0, EREFS0, IRCS, (-LP)
      const uint8_t c2;
      //! Control Register 4 - DMX32, DRST_DRS
      const uint8_t c4;
      //! Control Register 5 - PLLCLKEN0, PLLSTEN0, PRDIV0
      const uint8_t c5;
      //! Control Register 6 - LOLIE0, CME0, VDIV0, (-PLLS)
      const uint8_t c6;
      //! Status and Control Register - FCRDIV
      const uint8_t sc;
      //! Control Register 7 - OSCSEL
      const uint8_t c7;
      //! Control Register 8 - LOCRE1, LOLRE, CME1
      const uint8_t c8;
   };

   /**
    * Get MCGERCLK
    *
    * @return MCGERCLK as uint32_t
    */
   static uint32_t getErcClock() {

      switch((mcg().C7&MCG_C7_OSCSEL_MASK)) {
         default               : return 0;
         case MCG_C7_OSCSEL(0) : return Osc0Info::getOscClock();
         case MCG_C7_OSCSEL(1) : return RtcInfo::getInternalClock();
         case MCG_C7_OSCSEL(2) : return McgInfo::irc48m_clock;
      }
   }

   /**
    * Get Internal MCGIRCLK (ungated by MCG_C1_IRCLKEN_MASK)
    *
    * @return MCGIRCLK as uint32_t
    */
   static uint32_t getInternalIrcClock() {
         if (mcg().C2&MCG_C2_IRCS_MASK) {
   #ifdef MCG_SC_FCRDIV_MASK
            return (system_fast_irc_clock/(1<<((mcg().SC&MCG_SC_FCRDIV_MASK)>>MCG_SC_FCRDIV_SHIFT)));
   #else
            return system_fast_irc_clock;
   #endif
         }
         else {
            return system_slow_irc_clock;
         }
   }

   /**
    * Get MCGIRCLK (gated by MCG_C1_IRCLKEN_MASK)
    *
    * @return MCGIRCLK as uint32_t
    */
   static uint32_t getMcgIrClock() {
      if (mcg().C1&MCG_C1_IRCLKEN_MASK) {
         return getInternalIrcClock();
      }
      else {
         return 0;
      }
   }

};

/**
 * End group MCG_Group
 * @}
 */
/**
 * @addtogroup SIM_Group SIM, System Integration Module
 * @brief Abstraction for System Integration Module
 * @{
 */
#define USBDM_SIM_IS_DEFINED
/**
 * Peripheral information for SIM, System Integration Module.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Peripheral Clock sources
    */
   enum SimPeripheralClockSource {
      SimPeripheralClockSource_McgFll = SIM_SOPT2_PLLFLLSEL(0), //!< MCG FLL Clock
      SimPeripheralClockSource_McgPll = SIM_SOPT2_PLLFLLSEL(1), //!< MCG PLL Clock
      SimPeripheralClockSource_Irc48m = SIM_SOPT2_PLLFLLSEL(3), //!< IRC 48MHz clock
   };

   /**
    * LPUART Clock sources
    */
   enum SimLpuartClockSource {
      SimLpuartClockSource_Disabled   = SIM_SOPT2_LPUARTSRC(0), //!< Disabled
      SimLpuartClockSource_Peripheral = SIM_SOPT2_LPUARTSRC(1), //!< Peripheral clock selected by SIM.SOPT2[PLLFLLSEL] divided by SIM.CLKDIV3
      SimLpuartClockSource_OscerClk   = SIM_SOPT2_LPUARTSRC(2), //!< OSCERCLK clock
      SimLpuartClockSource_McgIrClk   = SIM_SOPT2_LPUARTSRC(3), //!< MCG Internal Reference clock (MCGIRCLK)
   };

   /**
    * USB full-speed clock sources
    */
   enum SimUsbFullSpeedClockSource {
      SimUsbFullSpeedClockSource_McgFll = SIM_SOPT2_USBSRC(0), //!< External bypass clock (USB_CLKIN)
      SimUsbFullSpeedClockSource_McgPll = SIM_SOPT2_USBSRC(1), //!< Peripheral clock selected by SIM.SOPT2[PLLFLLSEL] divided by SIM.CLKDIV2
   };

   /**
    * Selects the ADC0 Trigger source in STOP and VLPS modes, or when ADC0 Alternative Trigger is active.
    */
   enum SimAdc0Trigger {
      SimAdc0Trigger_PdbExTrig    = SIM_SOPT7_ADC0TRGSEL(0),   //!< External Trigger Source PDBx_EXTRG
      SimAdc0Trigger_Cmp0         = SIM_SOPT7_ADC0TRGSEL(1),   //!< Comparator 0
      SimAdc0Trigger_Cmp1         = SIM_SOPT7_ADC0TRGSEL(2),   //!< Comparator 1
      SimAdc0Trigger_Cmp2         = SIM_SOPT7_ADC0TRGSEL(3),   //!< Comparator 2 (if present)
      SimAdc0Trigger_PitCh0       = SIM_SOPT7_ADC0TRGSEL(4),   //!< PIT Channel 0
      SimAdc0Trigger_PitCh1       = SIM_SOPT7_ADC0TRGSEL(5),   //!< PIT Channel 1
      SimAdc0Trigger_PitCh2       = SIM_SOPT7_ADC0TRGSEL(6),   //!< PIT Channel 2
      SimAdc0Trigger_PitCh3       = SIM_SOPT7_ADC0TRGSEL(7),   //!< PIT Channel 3
      SimAdc0Trigger_Ftm0         = SIM_SOPT7_ADC0TRGSEL(8),   //!< FTM0 Init and Ext Trigger Outputs
      SimAdc0Trigger_Ftm1         = SIM_SOPT7_ADC0TRGSEL(9),   //!< FTM1 Init and Ext Trigger Outputs
      SimAdc0Trigger_Ftm2         = SIM_SOPT7_ADC0TRGSEL(10),  //!< FTM2 Init and Ext Trigger Outputs (if present)
      SimAdc0Trigger_Ftm3         = SIM_SOPT7_ADC0TRGSEL(11),  //!< FTM3 Init and Ext Trigger Outputs (if present)
      SimAdc0Trigger_RtcAlarm     = SIM_SOPT7_ADC0TRGSEL(12),  //!< RTC Alarm
      SimAdc0Trigger_RtcSeconds   = SIM_SOPT7_ADC0TRGSEL(13),  //!< RTC Seconds
      SimAdc0Trigger_Lptrm        = SIM_SOPT7_ADC0TRGSEL(14),  //!< LPTMR
      SimAdc0Trigger_15           = SIM_SOPT7_ADC0TRGSEL(15),  //!< Reserved
   };

   /**
    * Selects the ADC0 trigger mode.
    *
    *    _Pdb              - ADC is triggered by PDB which selects the pretrigger (SC1[0..n]/R[0..n]
    *    _Alt_PreTrigger_0 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
    *    _Alt_PreTrigger_1 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
    */
   enum SimAdc0TriggerMode {
      SimAdc0TriggerMode_Pdb               = SIM_SOPT7_ADC0ALTTRGEN(0),                              //!< PDB trigger
      SimAdc0TriggerMode_Alt_PreTrigger_0  = SIM_SOPT7_ADC0ALTTRGEN(1)|SIM_SOPT7_ADC0PRETRGSEL(0),   //!< Pre-trigger 0 = A (SC1[0])
      SimAdc0TriggerMode_Alt_PreTrigger_1  = SIM_SOPT7_ADC0ALTTRGEN(1)|SIM_SOPT7_ADC0PRETRGSEL(1),   //!< Pre-trigger 1 = B (SC1[1])
   };

   /**
    * Selects the ADC1 Trigger source in STOP and VLPS modes, or when ADC1 Alternative Trigger is active.
    */
   enum SimAdc1Trigger {
      SimAdc1Trigger_PdbExTrig    = SIM_SOPT7_ADC1TRGSEL(0),   //!< External Trigger Source PDBx_EXTRG
      SimAdc1Trigger_Cmp0         = SIM_SOPT7_ADC1TRGSEL(1),   //!< Comparator 0
      SimAdc1Trigger_Cmp1         = SIM_SOPT7_ADC1TRGSEL(2),   //!< Comparator 1
      SimAdc1Trigger_Cmp2         = SIM_SOPT7_ADC1TRGSEL(3),   //!< Comparator 2 (if present)
      SimAdc1Trigger_PitCh0       = SIM_SOPT7_ADC1TRGSEL(4),   //!< PIT Channel 0
      SimAdc1Trigger_PitCh1       = SIM_SOPT7_ADC1TRGSEL(5),   //!< PIT Channel 1
      SimAdc1Trigger_PitCh2       = SIM_SOPT7_ADC1TRGSEL(6),   //!< PIT Channel 2
      SimAdc1Trigger_PitCh3       = SIM_SOPT7_ADC1TRGSEL(7),   //!< PIT Channel 3
      SimAdc1Trigger_Ftm0         = SIM_SOPT7_ADC1TRGSEL(8),   //!< FTM0 Init and Ext Trigger Outputs
      SimAdc1Trigger_Ftm1         = SIM_SOPT7_ADC1TRGSEL(9),   //!< FTM1 Init and Ext Trigger Outputs
      SimAdc1Trigger_Ftm2         = SIM_SOPT7_ADC1TRGSEL(10),  //!< FTM2 Init and Ext Trigger Outputs (if present)
      SimAdc1Trigger_Ftm3         = SIM_SOPT7_ADC1TRGSEL(11),  //!< FTM3 Init and Ext Trigger Outputs (if present)
      SimAdc1Trigger_RtcAlarm     = SIM_SOPT7_ADC1TRGSEL(12),  //!< RTC Alarm
      SimAdc1Trigger_RtcSeconds   = SIM_SOPT7_ADC1TRGSEL(13),  //!< RTC Seconds
      SimAdc1Trigger_Lptrm        = SIM_SOPT7_ADC1TRGSEL(14),  //!< LPTMR
      SimAdc1Trigger_15           = SIM_SOPT7_ADC1TRGSEL(15),  //!< Reserved
   };

   /**
    * Selects the ADC1 trigger mode.
    *
    *    _Pdb              - ADC is triggered by PDB which selects the pretrigger (SC1[0..n]/R[0..n]
    *    _Alt_PreTrigger_0 - ADC is triggered by SimAdc1Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
    *    _Alt_PreTrigger_1 - ADC is triggered by SimAdc1Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
    */
   enum SimAdc1TriggerMode {
      SimAdc1TriggerMode_Pdb               = SIM_SOPT7_ADC1ALTTRGEN(0),                              //!< PDB trigger
      SimAdc1TriggerMode_Alt_PreTrigger_0  = SIM_SOPT7_ADC1ALTTRGEN(1)|SIM_SOPT7_ADC1PRETRGSEL(0),   //!< Alt trigger source, pre-trigger 0 = A (SC1[0])
      SimAdc1TriggerMode_Alt_PreTrigger_1  = SIM_SOPT7_ADC1ALTTRGEN(1)|SIM_SOPT7_ADC1PRETRGSEL(1),   //!< Alt trigger source, pre-trigger 1 = B (SC1[1])
   };

class SimInfo {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = SIM_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile SIM_Type &sim() {
      return *(SIM_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:sim_mk22f51212

   //! System Options Register 1
   static constexpr uint32_t sopt1 =
   #ifdef SIM_SOPT1_OSC32KOUT
      SIM_SOPT1_OSC32KOUT(0) |    // 32K oscillator clock out pin select
   #endif
      SIM_SOPT1_OSC32KSEL(3);     // 32K oscillator clock select

   /**
    * Get ERCLK32K clock frequency
    *
    * @return Clock frequency as a uint32_t in Hz
    */
   static uint32_t getErc32kClock() {

      switch(sim().SOPT1&SIM_SOPT1_OSC32KSEL_MASK) {
         default                     : return 0;
         case SIM_SOPT1_OSC32KSEL(0) : return Osc0Info::getOsc32kClock();
         case SIM_SOPT1_OSC32KSEL(2) : return RtcInfo::getExternalClock();
         case SIM_SOPT1_OSC32KSEL(3) : return 1000;
      }
   }

   /**
    * Set Peripheral clock source
    *
    * @param simPeripheralClockSource Clock source for peripheral clock
    */
   static void setPeripheralClock(SimPeripheralClockSource simPeripheralClockSource) {
      sim().SOPT2 = (sim().SOPT2&~SIM_SOPT2_PLLFLLSEL_MASK) | simPeripheralClockSource;
   }

   /**
    * Get Peripheral clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getPeripheralClock() {

      switch(sim().SOPT2&SIM_SOPT2_PLLFLLSEL_MASK) {
         default:                     return 0;
         case SIM_SOPT2_PLLFLLSEL(0): return SystemMcgFllClock;
         case SIM_SOPT2_PLLFLLSEL(1): return SystemMcgPllClock;
         case SIM_SOPT2_PLLFLLSEL(3): return McgInfo::irc48m_clock;
      }
   }

   /**
    * Set LPUART input clock source
    *
    * @param simLpuartClockSource Clock source for LPUART
    */
   static void setLpuartClock(SimLpuartClockSource simLpuartClockSource) {
      sim().SOPT2 = (sim().SOPT2&~SIM_SOPT2_LPUARTSRC_MASK) | simLpuartClockSource;
   }

   /**
    * Get LPUART input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getLpuartClock() {

      switch(sim().SOPT2&SIM_SOPT2_LPUARTSRC_MASK) {
      default:
      case SIM_SOPT2_LPUARTSRC(0): return 0;
      case SIM_SOPT2_LPUARTSRC(1): return getPeripheralClock();
      case SIM_SOPT2_LPUARTSRC(2): return Osc0Info::getOscerClock();
      case SIM_SOPT2_LPUARTSRC(3): return McgInfo::getMcgIrClock();
      }
   }

   /**
    * Get UART0 input clock frequency
    *
    * @return Clock frequency in Hz
    */
   static inline uint32_t getUart0Clock() {
      return SystemCoreClock;
   }

   /**
    * Get UART1 input clock frequency
    *
    * @return Clock frequency in Hz
    */
   static inline uint32_t getUart1Clock() {
      return SystemCoreClock;
   }

   /**
    * Get UART2 input clock frequency
    *
    * @return Clock frequency in Hz
    */
   static inline uint32_t getUart2Clock() {
      return SystemBusClock;
   }

   #ifdef SIM_SOPT2_USBSRC_MASK
   /**
    * Set USB Full-speed clock source
    *
    * @param simUsbFullSpeedClockSource Clock source for peripheral clock
    */
   static void setUsbFullSpeedClock(SimUsbFullSpeedClockSource simUsbFullSpeedClockSource) {
      sim().SOPT2 = (sim().SOPT2&~SIM_SOPT2_USBSRC_MASK) | simUsbFullSpeedClockSource;
   }

   /**
    * Get USB clock frequency
    *
    * @return Clock frequency as a uint32_t in Hz
    */
   static uint32_t getUsbClock() {
      switch ((sim().SOPT2&SIM_SOPT2_USBSRC_MASK)) {
         default:
         case SIM_SOPT2_USBSRC(0): return 48000000;
         case SIM_SOPT2_USBSRC(1): return  (getPeripheralClock()*
            (((sim().CLKDIV2&SIM_CLKDIV2_USBFRAC_MASK)>>SIM_CLKDIV2_USBFRAC_SHIFT)+1))/
            (((sim().CLKDIV2&SIM_CLKDIV2_USBDIV_MASK)>>SIM_CLKDIV2_USBDIV_SHIFT)+1);
      }
   }
   #endif

   //! System Options Register 2
   static constexpr uint32_t sopt2 =
   #ifdef SIM_SOPT2_TRACECLKSEL
      SIM_SOPT2_TRACECLKSEL(0) |      // Debug trace clock select
   #endif
   #ifdef SIM_SOPT2_TIMESRC
      SIM_SOPT2_TIMESRC(-1) |          // IEEE 1588 timestamp clock source select
   #endif
   #ifdef SIM_SOPT2_RMIISRC
      SIM_SOPT2_RMIISRC(-1) |          // Ethernet RMII clock source select
   #endif
   #ifdef SIM_SOPT2_SDHCSRC
         SIM_SOPT2_SDHCSRC(-1) |       // SDHC clock source select
   #endif
   #ifdef SIM_SOPT2_UART0SRC
      SIM_SOPT2_UART0SRC(-1) |         // UART0 clock source select
   #endif
   #ifdef SIM_SOPT2_LPUARTSRC
         SIM_SOPT2_LPUARTSRC(2) |     // LPUART clock source select
   #endif
   #ifdef SIM_SOPT2_LPUART0SRC
         SIM_SOPT2_LPUART0SRC(-1) |     // LPUART clock source select
   #endif
   #ifdef SIM_SOPT2_PTD7PAD
         SIM_SOPT2_PTD7PAD(-1) |       // PTD7 pad drive strength
   #endif
   #ifdef SIM_SOPT2_TPMSRC
         SIM_SOPT2_TPMSRC(-1) |        // TPM clock source select
   #endif
   #ifdef SIM_SOPT2_USBSRC
         SIM_SOPT2_USBSRC(1) |        // USB clock source select
   #endif
   #ifdef SIM_SOPT2_FBSL
         SIM_SOPT2_FBSL(-1) |          // FlexBus security level
   #endif
   #ifdef SIM_SOPT2_PLLFLLSEL
         SIM_SOPT2_PLLFLLSEL(3)|      // PLL/FLL clock select
   #endif
   #ifdef SIM_SOPT2_RTCCLKOUTSEL
         SIM_SOPT2_RTCCLKOUTSEL(1) |  // RTC clock out select
   #endif
         SIM_SOPT2_CLKOUTSEL(6);      // CLKOUT pin clock source select

   //! System Options Register 4
   static constexpr uint32_t sopt4 =
   #ifdef SIM_SOPT4_FTM3TRG1SRC
      SIM_SOPT4_FTM3TRG1SRC(1) |   // FlexTimer 3 Hardware Trigger 1 Source Select
   #endif
   #ifdef SIM_SOPT4_FTM3TRG0SRC
      SIM_SOPT4_FTM3TRG0SRC(1) |   // FlexTimer 3 Hardware Trigger 0 Source Select
   #endif
   #ifdef SIM_SOPT4_FTM0TRG1SRC
      SIM_SOPT4_FTM0TRG1SRC(0) |   // FlexTimer 0 Hardware Trigger 1 Source Select
   #endif
   #ifdef SIM_SOPT4_FTM0TRG0SRC
      SIM_SOPT4_FTM0TRG0SRC(0) |   // FlexTimer 0 Hardware Trigger 0 Source Select
   #endif
   #ifdef SIM_SOPT4_FTM3CLKSEL
      SIM_SOPT4_FTM3CLKSEL(0)  |   // FlexTimer 3 External Clock Pin Select
   #endif
   #ifdef SIM_SOPT4_FTM2CLKSEL
      SIM_SOPT4_FTM2CLKSEL(0)  |   // FlexTimer 2 External Clock Pin Select
   #endif
   #ifdef SIM_SOPT4_FTM1CLKSEL
      SIM_SOPT4_FTM1CLKSEL(0)  |   // FlexTimer 1 External Clock Pin Select
   #endif
   #ifdef SIM_SOPT4_FTM0CLKSEL
      SIM_SOPT4_FTM0CLKSEL(0)  |   // FlexTimer 0 External Clock Pin Select
   #endif
   #ifdef SIM_SOPT4_FTM2CH1SRC
      SIM_SOPT4_FTM2CH1SRC(0)  |   // FTM2 channel 1 input capture source select
   #endif
   #ifdef SIM_SOPT4_FTM2CH0SRC
      SIM_SOPT4_FTM2CH0SRC(0)  |   // FTM2 channel 0 input capture source select
   #endif
   #ifdef SIM_SOPT4_FTM1CH0SRC
      SIM_SOPT4_FTM1CH0SRC(0)  |   // FTM1 channel 0 input capture source select
   #endif
   #ifdef SIM_SOPT4_FTM3FLT0
      SIM_SOPT4_FTM3FLT0(0)    |   // FlexTimer 3 Fault 0 Select
   #endif
   #ifdef SIM_SOPT4_FTM2FLT0
      SIM_SOPT4_FTM2FLT0(0)    |   // FlexTimer 2 Fault 0 Select
   #endif
   #ifdef SIM_SOPT4_FTM1FLT0
      SIM_SOPT4_FTM1FLT0(0)    |   // FlexTimer 1 Fault 0 Select
   #endif
   #ifdef SIM_SOPT4_FTM0FLT3
      SIM_SOPT4_FTM0FLT3(-1)    |   // FlexTimer 0 Fault 3 Select
   #endif
   #ifdef SIM_SOPT4_FTM0FLT2
      SIM_SOPT4_FTM0FLT2(-1)    |   // FlexTimer 0 Fault 2 Select
   #endif
      SIM_SOPT4_FTM0FLT1(0)    |   // FlexTimer 0 Fault 1 Select
      SIM_SOPT4_FTM0FLT0(0);       // FlexTimer 0 Fault 0 Select

   //! System Options Register 5
   static constexpr uint32_t sopt5 =
      SIM_SOPT5_UART0TXSRC(0) |      // UART 0 transmit data source select
      SIM_SOPT5_UART0RXSRC(0) |      // UART 0 receive data source select
      SIM_SOPT5_UART1TXSRC(0) |      // UART 1 transmit data source select
      SIM_SOPT5_UART1RXSRC(0) |      // UART 1 receive data source select
   #ifdef SIM_SOPT5_LPUART0RXSRC
      SIM_SOPT5_LPUART0RXSRC(0) |  // LPUART 0 receive data source select
   #endif
   #ifdef SIM_SOPT5_LPUART0TXSRC
      SIM_SOPT5_LPUART0TXSRC(-1) |  // LPUART 0 transmit data source select
   #endif
   #ifdef SIM_SOPT5_LPUART1TXSRC
      SIM_SOPT5_LPUART1TXSRC(-1) | // LPUART 1 transmit data source select
   #endif
   #ifdef SIM_SOPT5_LPUART1RXSRC
      SIM_SOPT5_LPUART1RXSRC(-1) | // LPUART 1 receive data source select
   #endif
      0;

   /**
    * Select the ADC0 Trigger source
    *
    * If PDB is selected by SimAdc0Trigger then Pre-trigger 0/1 is determined by the PDB setup,
    * otherwise Pre-trigger 0/1 is determined by this parameter.
    * For example, setAdc0Triggers(SimAdc0TriggerMode_Alt_PreTrigger_1, SimAdc0Trigger_PitCh0) will set the trigger source
    * to PIT channel 0 and conversion will use SC1[1]/R[1].
    *
    * @param[in] simAdc0TriggerMode Select ADC0 Trigger mode
    * @param[in] simAdc0Trigger     Select the ADC0 Trigger source in STOP and VLPS modes, or when ADC0 Alternative Trigger is active.
    */
   static void setAdc0Triggers(SimAdc0TriggerMode simAdc0TriggerMode, SimAdc0Trigger simAdc0Trigger=SimAdc0Trigger_PdbExTrig) {
      sim().SOPT7 = (sim().SOPT7&~(SIM_SOPT7_ADC0TRGSEL_MASK|SIM_SOPT7_ADC0ALTTRGEN_MASK))|simAdc0Trigger|simAdc0TriggerMode;
   };

   /**
    * Select the ADC1 Trigger source
    *
    * If PDB is selected by SimAdc0Trigger then Pre-trigger 0/1 is determined by the PDB setup,
    * otherwise Pre-trigger 0/1 is determined by this parameter.
    * For example, setAdc1Triggers(SimAdc1TriggerMode_Alt_PreTrigger_1, SimAdc1Trigger_PitCh0) will set the trigger source
    * to PIT channel 0 and conversion will use SC1[1]/R[1].
    *
    * @param[in] simAdc1TriggerMode Select ADC1 Trigger mode
    * @param[in] simAdc1Trigger     Select the ADC1 Trigger source in STOP and VLPS modes, or when ADC0 Alternative Trigger is active.
    */
   static void setAdc1Triggers(SimAdc1TriggerMode simAdc1TriggerMode, SimAdc1Trigger simAdc1Trigger=SimAdc1Trigger_PdbExTrig) {
      sim().SOPT7 = (sim().SOPT7&~(SIM_SOPT7_ADC1TRGSEL_MASK|SIM_SOPT7_ADC1ALTTRGEN_MASK))|simAdc1Trigger|simAdc1TriggerMode;
   };

   //! System Options Register 7
   static constexpr uint32_t sopt7 =
   #ifdef SIM_SOPT7_ADC1ALTTRGEN
      SIM_SOPT7_ADC1ALTTRGEN(0) |    // ADC1 alternate trigger enable
      SIM_SOPT7_ADC1PRETRGSEL(0) |   // ADC1 pretrigger select
      SIM_SOPT7_ADC1TRGSEL(0) |      // ADC1 trigger select

   #endif
      SIM_SOPT7_ADC0ALTTRGEN(0) |    // ADC0 alternate trigger enable
      SIM_SOPT7_ADC0PRETRGSEL(0) |   // ADC0 pretrigger select
      SIM_SOPT7_ADC0TRGSEL(0);       // ADC0 trigger select

   //! System Options Register 8
   static constexpr uint32_t sopt8 =
      SIM_SOPT8_FTM3OCH7SRC(0) |   // FTM3 channel 7 output source
      SIM_SOPT8_FTM3OCH6SRC(0) |   // FTM3 channel 6 output source
      SIM_SOPT8_FTM3OCH5SRC(0) |   // FTM3 channel 5 output source
      SIM_SOPT8_FTM3OCH4SRC(0) |   // FTM3 channel 4 output source
      SIM_SOPT8_FTM3OCH3SRC(0) |   // FTM3 channel 3 output source
      SIM_SOPT8_FTM3OCH2SRC(0) |   // FTM3 channel 2 output source
      SIM_SOPT8_FTM3OCH1SRC(0) |   // FTM3 channel 1 output source
      SIM_SOPT8_FTM3OCH0SRC(3) |   // FTM3 channel 0 output source
      SIM_SOPT8_FTM0OCH7SRC(0) |   // FTM0 channel 7 output source
      SIM_SOPT8_FTM0OCH6SRC(0) |   // FTM0 channel 6 output source
      SIM_SOPT8_FTM0OCH5SRC(0) |   // FTM0 channel 5 output source
      SIM_SOPT8_FTM0OCH4SRC(0) |   // FTM0 channel 4 output source
      SIM_SOPT8_FTM0OCH3SRC(0) |   // FTM0 channel 3 output source
      SIM_SOPT8_FTM0OCH2SRC(0) |   // FTM0 channel 2 output source
      SIM_SOPT8_FTM0OCH1SRC(0) |   // FTM0 channel 1 output source
      SIM_SOPT8_FTM0OCH0SRC(0);    // FTM0 channel 0 output source

   #ifdef SIM_CLKDIV2_USBDIV_MASK
   //! System Clock Divider Register 2
   //! USB clock divider divisor & fraction
   static constexpr uint32_t clkdiv2 = 0;
   #endif

   /**
    * Initialise SIM registers
    */
   static void initRegs() {
   #ifdef SIM_SCGC4_USBOTG_MASK
      // The USB interface must be disabled for clock changes to have effect
      sim().SCGC4 &= ~SIM_SCGC4_USBOTG_MASK;
   #endif

      sim().SOPT1 = sopt1;
      // sim_sopt2_pllfllsel may also be altered by MCG clock code
      sim().SOPT2 = sopt2;
      sim().SOPT4 = sopt4;
      sim().SOPT5 = sopt5;
      sim().SOPT7 = sopt7;
      sim().SOPT8 = sopt8;

   #ifdef SIM_CLKDIV2_USBDIV_MASK
      sim().CLKDIV2 = clkdiv2;
   #endif
   }

};

/**
 * End group SIM_Group
 * @}
 */
/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Abstraction for Analogue Input
 * @{
 */
#define USBDM_ADC0_IS_DEFINED
/**
 * Peripheral information for ADC, Analogue Input.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Adc0Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = ADC0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile ADC_Type &adc() {
      return *(ADC_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      ADC0_IRQn, };

   // Template:adc0_diff_a

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   //! Default value for ADCx_CFG1 register
   static constexpr uint32_t cfg1  =
       ADC_CFG1_ADICLK(3)|
       ADC_CFG1_MODE(2)|
       ADC_CFG1_ADLSMP(0)|
       ADC_CFG1_ADIV(0)|
       ADC_CFG1_ADLPC(0);

   //! Default value for ADCx_CFG2 register
    static constexpr uint32_t cfg2  =
       ADC_CFG2_MUXSEL_MASK | // Choose 'b' channels
       ADC_CFG2_ADLSTS(0)|
       ADC_CFG2_ADHSC(0)|
       ADC_CFG2_ADACKEN(0);

   //! Default value for ADCx_SC2 register
   static constexpr uint32_t sc2  =
       ADC_SC2_ACFE(0)|
       ADC_SC2_ACFGT(0)|
       ADC_SC2_ACREN(0)|
       ADC_SC2_REFSEL(0)|
       ADC_SC2_DMAEN(0)|
       ADC_SC2_ADTRG(0);

   //! Default value for ADCx_CV1 register
   static constexpr uint32_t cv1  = 0;

   //! Default value for ADCx_CV2 register
   static constexpr uint32_t cv2  = 0;

   /**
    *  Enable clock to Adc0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableAdc0Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_ADC0_MASK;
#endif
   }

   /**
    *  Disable clock to Adc0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableAdc0Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_ADC0_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 24;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: ADC0_SE0             = ADC0_DP0 (p9)                  */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*   1: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   2: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   3: ADC0_SE3             = ADC1_DP0 (p11)                 */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*   4: ADC0_SE4b            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: ADC0_SE5b            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: ADC0_SE6b            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   7: ADC0_SE7b            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   8: ADC0_SE8             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   9: ADC0_SE9             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  10: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  11: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  12: ADC0_SE12            = PTB2 (p37)                     */  { PortBInfo,  GPIOB_BasePtr,  2,       PORT_PCR_MUX(0)|defaultPcrValue  },
         /*  13: ADC0_SE13            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  14: ADC0_SE14            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  15: ADC0_SE15            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  16: ADC0_SE16            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  17: ADC0_SE17            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  18: ADC0_SE18            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  19: ADC0_SE19            = ADC0_DM0 (p10)                 */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*  20: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  21: ADC0_SE21            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  22: ADC0_SE22            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  23: ADC0_SE23            = DAC0_OUT (p18)                 */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTB_CLOCK_MASK);
#endif
      PORTB->GPCLR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x0004UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTB_CLOCK_MASK);
#endif
      PORTB->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x4U);
   }

#define USBDM_ADC0_INFODP_IS_DEFINED
   class InfoDP {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {

            //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
            /*   0: ADC0_DP0             = ADC0_DP0 (p9)                  */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
            /*   1: ADC0_DP1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   2: ADC0_DP2             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   3: ADC0_DP3             = ADC1_DP0 (p11)                 */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       *
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   };

#define USBDM_ADC0_INFODM_IS_DEFINED
   class InfoDM {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {

            //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
            /*   0: ADC0_DM0             = ADC0_DM0 (p10)                 */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
            /*   1: ADC0_DM1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   2: ADC0_DM2             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   3: ADC0_DM3             = ADC1_DM0 (p12)                 */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       *
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   };

};

#define USBDM_ADC1_IS_DEFINED
/**
 * Peripheral information for ADC, Analogue Input.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Adc1Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = ADC1_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile ADC_Type &adc() {
      return *(ADC_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      ADC1_IRQn, };

   // Template:adc0_diff_a

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   //! Default value for ADCx_CFG1 register
   static constexpr uint32_t cfg1  =
       ADC_CFG1_ADICLK(3)|
       ADC_CFG1_MODE(2)|
       ADC_CFG1_ADLSMP(0)|
       ADC_CFG1_ADIV(0)|
       ADC_CFG1_ADLPC(0);

   //! Default value for ADCx_CFG2 register
    static constexpr uint32_t cfg2  =
       ADC_CFG2_MUXSEL_MASK | // Choose 'b' channels
       ADC_CFG2_ADLSTS(0)|
       ADC_CFG2_ADHSC(0)|
       ADC_CFG2_ADACKEN(0);

   //! Default value for ADCx_SC2 register
   static constexpr uint32_t sc2  =
       ADC_SC2_ACFE(0)|
       ADC_SC2_ACFGT(0)|
       ADC_SC2_ACREN(0)|
       ADC_SC2_REFSEL(0)|
       ADC_SC2_DMAEN(0)|
       ADC_SC2_ADTRG(0);

   //! Default value for ADCx_CV1 register
   static constexpr uint32_t cv1  = 0;

   //! Default value for ADCx_CV2 register
   static constexpr uint32_t cv2  = 0;

   /**
    *  Enable clock to Adc1
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableAdc1Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_ADC1_MASK;
#endif
   }

   /**
    *  Disable clock to Adc1
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableAdc1Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_ADC1_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 40;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: ADC1_SE0             = ADC1_DP0 (p11)                 */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*   1: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   2: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   3: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   4: ADC1_SE4b            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: ADC1_SE5b            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: ADC1_SE6b            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   7: ADC1_SE7b            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   8: ADC1_SE8             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   9: ADC1_SE9             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  10: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  11: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  12: ADC1_SE12            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  13: ADC1_SE13            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  14: ADC1_SE14            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  15: ADC1_SE15            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  16: ADC1_SE16            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  17: ADC1_SE17            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  18: ADC1_SE18            = VREF_OUT (p17)                 */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*  19: ADC1_SE19            = ADC1_DM0 (p12)                 */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*  20: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  21: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  22: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  23: ADC1_SE23            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  24: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  25: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  26: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  27: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  28: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  29: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  30: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  31: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  32: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  33: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  34: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  35: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  36: ADC1_SE4a            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  37: ADC1_SE5a            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  38: ADC1_SE6a            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  39: ADC1_SE7a            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

#define USBDM_ADC1_INFODP_IS_DEFINED
   class InfoDP {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {

            //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
            /*   0: ADC1_DP0             = ADC1_DP0 (p11)                 */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
            /*   1: ADC1_DP1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   2: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
            /*   3: ADC1_DP3             = ADC0_DP0 (p9)                  */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       *
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   };

#define USBDM_ADC1_INFODM_IS_DEFINED
   class InfoDM {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {

            //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
            /*   0: ADC1_DM0             = ADC1_DM0 (p12)                 */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
            /*   1: ADC1_DM1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   2: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
            /*   3: ADC1_DM3             = ADC0_DM0 (p10)                 */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       *
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   };

};

/**
 * End group ADC_Group
 * @}
 */
/**
 * @addtogroup CMP_Group CMP, Analogue Comparator
 * @brief Abstraction for Analogue Comparator
 * @{
 */
#define USBDM_CMP0_IS_DEFINED
/**
 * Peripheral information for CMP, Analogue Comparator.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Cmp0Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = CMP0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile CMP_Type &cmp() {
      return *(CMP_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      CMP0_IRQn, };

   // Template:cmp0_mk22f

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Pin number in Info table for comparator output
   static constexpr int outputPin  = 8;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! CMP Control Register 0
   static constexpr uint32_t cr0 =
      CMP_CR0_FILTER_CNT(4)     | // Filter Sample Count
      CMP_CR0_HYSTCTR(3);         // Comparator hard block hysteresis control

   #ifndef CMP_CR1_TRIGM
   #define CMP_CR1_TRIGM(x) 0
   #endif

   //! CMP Control Register 1
   static constexpr uint32_t cr1 =
      CMP_CR1_SE(0)    | // Sample Enable
      CMP_CR1_WE(0)    | // Windowing Enable
      CMP_CR1_TRIGM(0) | // Trigger Mode Enable
      CMP_CR1_PMODE(0) | // Power mode Select
      CMP_CR1_INV(0)   | // Comparator Invert
      CMP_CR1_COS(0)   | // Comparator Output Select
      CMP_CR1_OPE(0);    // Comparator Output Pin Enable

   //! CMP Filter Period Register
   static constexpr uint32_t fpr =
      CMP_FPR_FILT_PER(20); // Filter Sample Period

   //! CMP Status and Control Register
   static constexpr uint32_t scr =
   #ifdef CMP_SCR_DMAEN
      CMP_SCR_DMAEN(0) | // DMA Enable Control
   #endif
      CMP_SCR_IER(1) | // Comparator Interrupt Enable Rising
      CMP_SCR_IEF(1);  // Comparator Interrupt Enable Falling

   //! DAC Control Register
   static constexpr uint32_t daccr =
      CMP_DACCR_VRSEL(1); // Supply Voltage Reference Source Select

   /**
    *  Enable clock to Cmp0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableCmp0Clock();
#else
      SIM->SCGC4 |= SIM_SCGC4_CMP_MASK;
#endif
   }

   /**
    *  Disable clock to Cmp0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableCmp0Clock();
#else
      SIM->SCGC4 &= ~SIM_SCGC4_CMP_MASK;
#endif
   }

   //! MUX Control Register
   static constexpr uint32_t muxcr =
      CMP_MUXCR_PSEL(1)| // Plus Input Mux Control
      CMP_MUXCR_MSEL(7); // Minus Input Mux Control

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 1;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   //! Number of signals available in info table
   static constexpr int numSignals  = 9;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: CMP0_IN0             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: CMP0_IN1             = PTC7 (p52)                     */  { PortCInfo,  GPIOC_BasePtr,  7,       PORT_PCR_MUX(0)|defaultPcrValue  },
         /*   2: CMP0_IN2             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: CMP0_IN3             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: CMP0_IN4             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: CMP0_IN5             = VREF_OUT (p17)                 */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*   6: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   7: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   8: CMP0_OUT             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTC = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTC_CLOCK_MASK);
#endif
      PORTC->GPCLR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x0080UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTC = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTC_CLOCK_MASK);
#endif
      PORTC->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x80U);
   }

};

#define USBDM_CMP1_IS_DEFINED
/**
 * Peripheral information for CMP, Analogue Comparator.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Cmp1Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = CMP1_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile CMP_Type &cmp() {
      return *(CMP_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      CMP1_IRQn, };

   // Template:cmp1_mk22f

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Pin number in Info table for comparator output
   static constexpr int outputPin  = 8;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! CMP Control Register 0
   static constexpr uint32_t cr0 =
      CMP_CR0_FILTER_CNT(0)     | // Filter Sample Count
      CMP_CR0_HYSTCTR(0);         // Comparator hard block hysteresis control

   #ifndef CMP_CR1_TRIGM
   #define CMP_CR1_TRIGM(x) 0
   #endif

   //! CMP Control Register 1
   static constexpr uint32_t cr1 =
      CMP_CR1_SE(0)    | // Sample Enable
      CMP_CR1_WE(0)    | // Windowing Enable
      CMP_CR1_TRIGM(0) | // Trigger Mode Enable
      CMP_CR1_PMODE(0) | // Power mode Select
      CMP_CR1_INV(0)   | // Comparator Invert
      CMP_CR1_COS(0)   | // Comparator Output Select
      CMP_CR1_OPE(0);    // Comparator Output Pin Enable

   //! CMP Filter Period Register
   static constexpr uint32_t fpr =
      CMP_FPR_FILT_PER(0); // Filter Sample Period

   //! CMP Status and Control Register
   static constexpr uint32_t scr =
   #ifdef CMP_SCR_DMAEN
      CMP_SCR_DMAEN(0) | // DMA Enable Control
   #endif
      CMP_SCR_IER(0) | // Comparator Interrupt Enable Rising
      CMP_SCR_IEF(0);  // Comparator Interrupt Enable Falling

   //! DAC Control Register
   static constexpr uint32_t daccr =
      CMP_DACCR_VRSEL(0); // Supply Voltage Reference Source Select

   /**
    *  Enable clock to Cmp1
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableCmp1Clock();
#else
      SIM->SCGC4 |= SIM_SCGC4_CMP_MASK;
#endif
   }

   /**
    *  Disable clock to Cmp1
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableCmp1Clock();
#else
      SIM->SCGC4 &= ~SIM_SCGC4_CMP_MASK;
#endif
   }

   //! MUX Control Register
   static constexpr uint32_t muxcr =
      CMP_MUXCR_PSEL(0)| // Plus Input Mux Control
      CMP_MUXCR_MSEL(0); // Minus Input Mux Control

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   //! Number of signals available in info table
   static constexpr int numSignals  = 9;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: CMP1_IN0             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: CMP1_IN1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: CMP1_IN2             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: CMP1_IN3             = DAC0_OUT (p18)                 */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*   4: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   5: CMP1_IN5             = VREF_OUT (p17)                 */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*   6: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   7: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   8: CMP1_OUT             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/**
 * End group CMP_Group
 * @}
 */
/**
 * @addtogroup Control_Group CONTROL, Control
 * @brief Abstraction for Control
 * @{
 */
#define USBDM_CONTROL_IS_DEFINED
/**
 * Peripheral information for CONTROL, Control.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class ControlInfo {
public:
   // Template:control

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 12;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: RESET_b              = RESET_b (p34)                  */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*   1: JTAG_TCLK            = PTA0 (p22)                     */  { PortAInfo,  GPIOA_BasePtr,  0,       PORT_PCR_MUX(7)|defaultPcrValue  },
         /*   2: SWD_CLK              = PTA0 (p22)                     */  { PortAInfo,  GPIOA_BasePtr,  0,       PORT_PCR_MUX(7)|defaultPcrValue  },
         /*   3: JTAG_TDI             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: JTAG_TDO             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: TRACE_SWO            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: JTAG_TMS             = PTA3 (p25)                     */  { PortAInfo,  GPIOA_BasePtr,  3,       PORT_PCR_MUX(7)|defaultPcrValue  },
         /*   7: SWD_DIO              = PTA3 (p25)                     */  { PortAInfo,  GPIOA_BasePtr,  3,       PORT_PCR_MUX(7)|defaultPcrValue  },
         /*   8: NMI_b                = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   9: JTAG_TRST_b          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  10: CLKOUT               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  11: CLKOUT32K            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTA_CLOCK_MASK);
#endif
      PORTA->GPCLR = pcrValue|PORT_PCR_MUX(7)|PORT_GPCLR_GPWE(0x0009UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTA_CLOCK_MASK);
#endif
      PORTA->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x9U);
   }

};

/**
 * End group Control_Group
 * @}
 */
/**
 * @addtogroup CRC_Group CRC, Cyclic Redundancy Check
 * @brief Abstraction for Cyclic Redundancy Check
 * @{
 */
#define USBDM_CRC0_IS_DEFINED
/**
 * Peripheral information for CRC, Cyclic Redundancy Check.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Crc0Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = CRC0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile CRC_Type &crc() {
      return *(CRC_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:crc0_0x40032000

   static constexpr uint32_t gpoly =  0;

   /**
    *  Enable clock to Crc0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableCrc0Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_CRC_MASK;
#endif
   }

   /**
    *  Disable clock to Crc0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableCrc0Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_CRC_MASK;
#endif
   }

};

/**
 * End group CRC_Group
 * @}
 */
/**
 * @addtogroup CONSOLE_Group Console, Console Interface
 * @brief Abstraction for Console Interface
 * @{
 */
/**
 * End group CONSOLE_Group
 * @}
 */
/**
 * @addtogroup DAC_Group DAC, Digital-to-Analogue Converter
 * @brief Abstraction for Digital-to-Analogue Converter
 * @{
 */
#define USBDM_DAC0_IS_DEFINED
/**
 * Peripheral information for DAC, Digital-to-Analogue Converter.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Dac0Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = DAC0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile DAC_Type &dac() {
      return *(DAC_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      DAC0_IRQn, };

   // Template:dac0_16ch_fifo16

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! DAC Control Register 0
   static constexpr uint32_t c0 =
      DAC_C0_DACRFS(1)        | // Reference Select
      DAC_C0_DACTRGSEL(1)     | // Trigger Select
      DAC_C0_LPEN(0)          | // Low Power Control
      DAC_C0_DACBWIEN(0)      | // Buffer Watermark Interrupt Enable
      DAC_C0_DACBTIEN(0)      | // Buffer Read Pointer Top Flag Interrupt Enable
      DAC_C0_DACBBIEN(0);       // Buffer Read Pointer Bottom Flag Interrupt Enable

   //! DAC Control Register 1
   static constexpr uint32_t c1 =
      DAC_C1_DMAEN(0)       | // DMA Enable Select
      DAC_C1_DACBFWM(0)     | // Buffer Watermark Select
      DAC_C1_DACBFMD(0)     | // Buffer Work Mode Select
      DAC_C1_DACBFEN(0);      // Buffer Enable
   //! DAC Control Register 2
   static constexpr uint32_t c2 =
      DAC_C2_DACBFUP(1);   // DAC Buffer Upper Limit
   /**
    *  Enable clock to Dac0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableDac0Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_DAC0_MASK;
#endif
   }

   /**
    *  Disable clock to Dac0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableDac0Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_DAC0_MASK;
#endif
   }

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: DAC0_OUT             = DAC0_OUT (p18)                 */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_DAC1_IS_DEFINED
/**
 * Peripheral information for DAC, Digital-to-Analogue Converter.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Dac1Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = DAC1_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile DAC_Type &dac() {
      return *(DAC_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      DAC1_IRQn, };

   // Template:dac0_16ch_fifo16

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! DAC Control Register 0
   static constexpr uint32_t c0 =
      DAC_C0_DACRFS(1)        | // Reference Select
      DAC_C0_DACTRGSEL(1)     | // Trigger Select
      DAC_C0_LPEN(0)          | // Low Power Control
      DAC_C0_DACBWIEN(0)      | // Buffer Watermark Interrupt Enable
      DAC_C0_DACBTIEN(0)      | // Buffer Read Pointer Top Flag Interrupt Enable
      DAC_C0_DACBBIEN(0);       // Buffer Read Pointer Bottom Flag Interrupt Enable

   //! DAC Control Register 1
   static constexpr uint32_t c1 =
      DAC_C1_DMAEN(0)       | // DMA Enable Select
      DAC_C1_DACBFWM(0)     | // Buffer Watermark Select
      DAC_C1_DACBFMD(0)     | // Buffer Work Mode Select
      DAC_C1_DACBFEN(0);      // Buffer Enable
   //! DAC Control Register 2
   static constexpr uint32_t c2 =
      DAC_C2_DACBFUP(1);   // DAC Buffer Upper Limit
   /**
    *  Enable clock to Dac1
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableDac1Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_DAC1_MASK;
#endif
   }

   /**
    *  Disable clock to Dac1
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableDac1Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_DAC1_MASK;
#endif
   }

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: DAC1_OUT             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/**
 * End group DAC_Group
 * @}
 */
/**
 * @addtogroup DMA_Group DMA, Direct Memory Access (DMA)
 * @brief Abstraction for Direct Memory Access (DMA)
 * @{
 */
#define USBDM_DMA0_IS_DEFINED
/**
 * Peripheral information for DMA, Direct Memory Access (DMA).
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Dma0Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = DMA0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile DMA_Type &dma() {
      return *(DMA_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 17;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      DMA0_IRQn, DMA1_IRQn, DMA2_IRQn, DMA3_IRQn,
      DMA4_IRQn, DMA5_IRQn, DMA6_IRQn, DMA7_IRQn,
      DMA8_IRQn, DMA9_IRQn, DMA10_IRQn, DMA11_IRQn,
      DMA12_IRQn, DMA13_IRQn, DMA14_IRQn, DMA15_IRQn,
      DMA_Error_IRQn, };

   // Template:dma0_16ch_ears16

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   //! Number of DMA channels implemented
   static constexpr unsigned NumChannels = 16;

   //! Number of DMA vectors implemented
   static constexpr unsigned NumVectors = 16;

};

/**
 * End group DMA_Group
 * @}
 */
/**
 * @addtogroup DMAMUX_Group DMAMUX, Direct Memory Access (DMA)
 * @brief Abstraction for Direct Memory Access (DMA)
 * @{
 */
#define USBDM_DMAMUX0_IS_DEFINED
/**
 * Peripheral information for DMAMUX, Direct Memory Access (DMA).
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Dmamux0Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = DMAMUX0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile DMAMUX_Type &dmamux() {
      return *(DMAMUX_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:dmamux0_16ch_trig_mk22f51212

   /**
    *  Enable clock to Dmamux0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableDmamux0Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_DMAMUX0_MASK;
#endif
   }

   /**
    *  Disable clock to Dmamux0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableDmamux0Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_DMAMUX0_MASK;
#endif
   }

   // Number of DMA channels implemented
   static constexpr unsigned NumChannels = 16;

   static constexpr uint8_t chcfg0_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg1_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg2_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg3_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg4_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg5_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg6_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg7_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg8_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg9_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg10_source = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg11_source = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg12_source = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg13_source = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg14_source = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg15_source = DMAMUX_CHCFG_SOURCE(0);
};

/**
 * End group DMAMUX_Group
 * @}
 */
/**
 * @addtogroup EWM_Group EWM, External Watchdog Monitor
 * @brief Abstraction for External Watchdog Monitor
 * @{
 */
#define USBDM_EWM_IS_DEFINED
/**
 * Peripheral information for EWM, External Watchdog Monitor.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class EwmInfo {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = EWM_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile EWM_Type &ewm() {
      return *(EWM_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      WDOG_IRQn, };

   // Template:ewm_int_pr

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /**
    *  Enable clock to Ewm
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableEwmClock();
#else
      SIM->SCGC4 |= SIM_SCGC4_EWM_MASK;
#endif
   }

   /**
    *  Disable clock to Ewm
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableEwmClock();
#else
      SIM->SCGC4 &= ~SIM_SCGC4_EWM_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: EWM_IN               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: EWM_OUT_b            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/**
 * End group EWM_Group
 * @}
 */
/**
 * @addtogroup FB_Group FB, Flexbus - External Bus Interface
 * @brief Abstraction for Flexbus - External Bus Interface
 * @{
 */
#define USBDM_FB_IS_DEFINED
/**
 * Peripheral information for FB, Flexbus - External Bus Interface.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class FbInfo {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = FB_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile FB_Type &fb() {
      return *(FB_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:fb

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   /**
    *  Enable clock to Fb
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableFbClock();
#else
      SIM->SCGC7 |= SIM_SCGC7_FLEXBUS_MASK;
#endif
   }

   /**
    *  Disable clock to Fb
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableFbClock();
#else
      SIM->SCGC7 &= ~SIM_SCGC7_FLEXBUS_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 82;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: FB_CS0_b             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: FB_CS1_b             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: FB_CS2_b             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: FB_CS3_b             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: FB_CS4_b             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: FB_CS5_b             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: FB_AD0               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   7: FB_AD1               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   8: FB_AD2               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   9: FB_AD3               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  10: FB_AD4               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  11: FB_AD5               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  12: FB_AD6               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  13: FB_AD7               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  14: FB_AD8               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  15: FB_AD9               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  16: FB_AD10              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  17: FB_AD11              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  18: FB_AD12              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  19: FB_AD13              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  20: FB_AD14              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  21: FB_AD15              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  22: FB_AD16              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  23: FB_AD17              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  24: FB_AD18              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  25: FB_AD19              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  26: FB_AD20              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  27: FB_AD21              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  28: FB_AD22              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  29: FB_AD23              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  30: FB_AD24              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  31: FB_AD25              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  32: FB_AD26              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  33: FB_AD27              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  34: FB_AD28              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  35: FB_AD29              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  36: FB_AD30              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  37: FB_AD31              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  38: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  39: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  40: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  41: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  42: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  43: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  44: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  45: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  46: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  47: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  48: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  49: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  50: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  51: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  52: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  53: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  54: FB_A16               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  55: FB_A17               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  56: FB_A18               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  57: FB_A19               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  58: FB_A20               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  59: FB_A21               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  60: FB_A22               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  61: FB_A23               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  62: FB_A24               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  63: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  64: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  65: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  66: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  67: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  68: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  69: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  70: FB_TSIZ0             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  71: FB_TSIZ1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  72: FB_ALE               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  73: FB_OE_b              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  74: FB_RW_b              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  75: FB_TA_b              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  76: FB_TBST_b            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  77: FB_TS_b              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  78: FB_BE7_0_BLS31_24_b  = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  79: FB_BE15_8_BLS23_16_b = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  80: FB_BE23_16_BLS15_8_b = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  81: FB_BE31_24_BLS7_0_b  = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/**
 * End group FB_Group
 * @}
 */
/**
 * @addtogroup FTFA_Group FTFA, Flash Memory Module
 * @brief Abstraction for Flash Memory Module
 * @{
 */
#define USBDM_FTFA_IS_DEFINED
/**
 * Peripheral information for FTFA, Flash Memory Module.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class FtfaInfo {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = FTFA_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile FTFA_Type &ftfa() {
      return *(FTFA_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      FTF_Command_IRQn, FTF_ReadCollision_IRQn, };

   // Template:ftfa

   /**
    *  Enable clock to Ftfa
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableFtfaClock();
#else
      SIM->SCGC6 |= SIM_SCGC6_FTF_MASK;
#endif
   }

   /**
    *  Disable clock to Ftfa
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableFtfaClock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_FTF_MASK;
#endif
   }

};

/**
 * End group FTFA_Group
 * @}
 */
/**
 * @addtogroup FTM_Group FTM, PWM, Input capture and Output compare
 * @brief Abstraction for PWM, Input capture and Output compare
 * @{
 */
#define USBDM_FTM_IS_DEFINED
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class FtmInfo {
public:
   // Template:ftm

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: FTM_CLKIN0           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: FTM_CLKIN1           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_FTM0_IS_DEFINED
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Ftm0Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = FTM0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile FTM_Type &ftm() {
      return *(FTM_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      FTM0_IRQn, };

   // Template:ftm0_8ch_icrst

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Number of channels implemented
   static constexpr unsigned NumChannels = 8;

   //! Number of channel event vectors implemented
   static constexpr unsigned NumChannelVectors = 1;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Timer external input frequency
   static constexpr uint32_t ftmExternalClock =  0;

   //! Default Timer Modulo
   static constexpr uint32_t modulo = FTM_MOD_MOD(10000);

   //! Default value for SC register
   static constexpr uint32_t sc  =
       FTM_SC_CPWMS(0)| // Centre-Aligned PWM Select
       FTM_SC_CLKS(1)|  // Clock Mode Selection
       FTM_SC_TOIE(0)|  // Timer Overflow Interrupt Enable
       FTM_SC_PS(0);    // Prescale Factor Selection

   //! Default value for EXTTRIG) register
   static constexpr uint32_t exttrig  =
       0x0|                              // External Trigger Enable
       FTM_EXTTRIG_INITTRIGEN(0);    // Initialization Trigger Enable

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /** Minimum resolution for PWM interval */
   static constexpr uint32_t minimumResolution=100;

   /** Minimum usable interval in ticks */
   static constexpr uint32_t minimumInterval=20;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {

      switch(ftm().SC&FTM_SC_CLKS_MASK) {
      default:
      case FTM_SC_CLKS(0): return 0;
      case FTM_SC_CLKS(1): return SystemBusClock;
      case FTM_SC_CLKS(2): return SystemMcgffClock;
      case FTM_SC_CLKS(3): return ftmExternalClock;
      }
   }

   /**
    *  Enable clock to Ftm0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableFtm0Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_FTM0_MASK;
#endif
   }

   /**
    *  Disable clock to Ftm0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableFtm0Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_FTM0_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: FTM0_CH0             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: FTM0_CH1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: FTM0_CH2             = PTC3 (p46)                     */  { PortCInfo,  GPIOC_BasePtr,  3,       PORT_PCR_MUX(4)|defaultPcrValue  },
         /*   3: FTM0_CH3             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: FTM0_CH4             = PTD4 (p61)                     */  { PortDInfo,  GPIOD_BasePtr,  4,       PORT_PCR_MUX(4)|defaultPcrValue  },
         /*   5: FTM0_CH5             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: FTM0_CH6             = PTD6 (p63)                     */  { PortDInfo,  GPIOD_BasePtr,  6,       PORT_PCR_MUX(4)|defaultPcrValue  },
         /*   7: FTM0_CH7             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTC = PCC_PCCn_CGC_MASK;
      PCC->PCC_PORTD = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTC_CLOCK_MASK|PORTD_CLOCK_MASK);
#endif
      PORTC->GPCLR = pcrValue|PORT_PCR_MUX(4)|PORT_GPCLR_GPWE(0x0008UL);
      PORTD->GPCLR = pcrValue|PORT_PCR_MUX(4)|PORT_GPCLR_GPWE(0x0050UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTC = PCC_PCCn_CGC_MASK;
      PCC->PCC_PORTD = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTC_CLOCK_MASK|PORTD_CLOCK_MASK);
#endif
      PORTC->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x8U);
      PORTD->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x50U);
   }

#define USBDM_FTM0_INFOFAULT_IS_DEFINED
   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {

            //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
            /*   0: FTM0_FLT0            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   1: FTM0_FLT1            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   2: FTM0_FLT2            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   3: FTM0_FLT3            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       *
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   };

};

#define USBDM_FTM1_IS_DEFINED
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Ftm1Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = FTM1_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile FTM_Type &ftm() {
      return *(FTM_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      FTM1_IRQn, };

   // Template:ftm1_2ch_icrst

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Number of channels implemented
   static constexpr unsigned NumChannels = 2;

   //! Number of channel event vectors implemented
   static constexpr unsigned NumChannelVectors = 1;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Timer external input frequency
   static constexpr uint32_t ftmExternalClock =  0;

   //! Default Timer Modulo
   static constexpr uint32_t modulo = FTM_MOD_MOD(10000);

   //! Default value for SC register
   static constexpr uint32_t sc  =
       FTM_SC_CPWMS(0)| // Centre-Aligned PWM Select
       FTM_SC_CLKS(1)|  // Clock Mode Selection
       FTM_SC_TOIE(0)|  // Timer Overflow Interrupt Enable
       FTM_SC_PS(0);    // Prescale Factor Selection

   //! Default value for EXTTRIG) register
   static constexpr uint32_t exttrig  =
       0x0|                              // External Trigger Enable
       FTM_EXTTRIG_INITTRIGEN(0);    // Initialization Trigger Enable

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /** Minimum resolution for PWM interval */
   static constexpr uint32_t minimumResolution=100;

   /** Minimum usable interval in ticks */
   static constexpr uint32_t minimumInterval=20;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {

      switch(ftm().SC&FTM_SC_CLKS_MASK) {
      default:
      case FTM_SC_CLKS(0): return 0;
      case FTM_SC_CLKS(1): return SystemBusClock;
      case FTM_SC_CLKS(2): return SystemMcgffClock;
      case FTM_SC_CLKS(3): return ftmExternalClock;
      }
   }

   /**
    *  Enable clock to Ftm1
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableFtm1Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_FTM1_MASK;
#endif
   }

   /**
    *  Disable clock to Ftm1
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableFtm1Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_FTM1_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: FTM1_CH0             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: FTM1_CH1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

#define USBDM_FTM1_INFOFAULT_IS_DEFINED
   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 1;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {

            //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
            /*   0: FTM1_FLT0            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       *
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   };

#define USBDM_FTM1_INFOQUAD_IS_DEFINED
   class InfoQUAD {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 2;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {

            //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
            /*   0: FTM1_QD_PHA          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   1: FTM1_QD_PHB          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       *
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   };

};

#define USBDM_FTM2_IS_DEFINED
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Ftm2Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = FTM2_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile FTM_Type &ftm() {
      return *(FTM_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      FTM2_IRQn, };

   // Template:ftm1_2ch_icrst

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Number of channels implemented
   static constexpr unsigned NumChannels = 2;

   //! Number of channel event vectors implemented
   static constexpr unsigned NumChannelVectors = 1;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Timer external input frequency
   static constexpr uint32_t ftmExternalClock =  0;

   //! Default Timer Modulo
   static constexpr uint32_t modulo = FTM_MOD_MOD(10000);

   //! Default value for SC register
   static constexpr uint32_t sc  =
       FTM_SC_CPWMS(0)| // Centre-Aligned PWM Select
       FTM_SC_CLKS(1)|  // Clock Mode Selection
       FTM_SC_TOIE(0)|  // Timer Overflow Interrupt Enable
       FTM_SC_PS(0);    // Prescale Factor Selection

   //! Default value for EXTTRIG) register
   static constexpr uint32_t exttrig  =
       0x0|                              // External Trigger Enable
       FTM_EXTTRIG_INITTRIGEN(0);    // Initialization Trigger Enable

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /** Minimum resolution for PWM interval */
   static constexpr uint32_t minimumResolution=100;

   /** Minimum usable interval in ticks */
   static constexpr uint32_t minimumInterval=20;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {

      switch(ftm().SC&FTM_SC_CLKS_MASK) {
      default:
      case FTM_SC_CLKS(0): return 0;
      case FTM_SC_CLKS(1): return SystemBusClock;
      case FTM_SC_CLKS(2): return SystemMcgffClock;
      case FTM_SC_CLKS(3): return ftmExternalClock;
      }
   }

   /**
    *  Enable clock to Ftm2
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableFtm2Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_FTM2_MASK;
#endif
   }

   /**
    *  Disable clock to Ftm2
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableFtm2Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_FTM2_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: FTM2_CH0             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: FTM2_CH1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

#define USBDM_FTM2_INFOFAULT_IS_DEFINED
   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 1;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {

            //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
            /*   0: FTM2_FLT0            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       *
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   };

#define USBDM_FTM2_INFOQUAD_IS_DEFINED
   class InfoQUAD {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 2;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {

            //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
            /*   0: FTM2_QD_PHA          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   1: FTM2_QD_PHB          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       *
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   };

};

#define USBDM_FTM3_IS_DEFINED
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Ftm3Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = FTM3_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile FTM_Type &ftm() {
      return *(FTM_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      FTM3_IRQn, };

   // Template:ftm0_8ch_icrst

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Number of channels implemented
   static constexpr unsigned NumChannels = 8;

   //! Number of channel event vectors implemented
   static constexpr unsigned NumChannelVectors = 1;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Timer external input frequency
   static constexpr uint32_t ftmExternalClock =  0;

   //! Default Timer Modulo
   static constexpr uint32_t modulo = FTM_MOD_MOD(10000);

   //! Default value for SC register
   static constexpr uint32_t sc  =
       FTM_SC_CPWMS(0)| // Centre-Aligned PWM Select
       FTM_SC_CLKS(1)|  // Clock Mode Selection
       FTM_SC_TOIE(0)|  // Timer Overflow Interrupt Enable
       FTM_SC_PS(0);    // Prescale Factor Selection

   //! Default value for EXTTRIG) register
   static constexpr uint32_t exttrig  =
       0x0|                              // External Trigger Enable
       FTM_EXTTRIG_INITTRIGEN(0);    // Initialization Trigger Enable

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /** Minimum resolution for PWM interval */
   static constexpr uint32_t minimumResolution=100;

   /** Minimum usable interval in ticks */
   static constexpr uint32_t minimumInterval=20;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {

      switch(ftm().SC&FTM_SC_CLKS_MASK) {
      default:
      case FTM_SC_CLKS(0): return 0;
      case FTM_SC_CLKS(1): return SystemBusClock;
      case FTM_SC_CLKS(2): return SystemMcgffClock;
      case FTM_SC_CLKS(3): return ftmExternalClock;
      }
   }

   /**
    *  Enable clock to Ftm3
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableFtm3Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_FTM3_MASK;
#endif
   }

   /**
    *  Disable clock to Ftm3
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableFtm3Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_FTM3_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: FTM3_CH0             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: FTM3_CH1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: FTM3_CH2             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: FTM3_CH3             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: FTM3_CH4             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: FTM3_CH5             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: FTM3_CH6             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   7: FTM3_CH7             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

#define USBDM_FTM3_INFOFAULT_IS_DEFINED
   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 1;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {

            //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
            /*   0: FTM3_FLT0            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       *
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   };

};

/**
 * End group FTM_Group
 * @}
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Abstraction for Digital Input/Output
 * @{
 */
#define USBDM_GPIOA_IS_DEFINED
/**
 * Peripheral information for GPIO, Digital Input/Output.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioAInfo {
public:
   // Template:gpioa_0x400ff000

   //! Describes the port/gpio
   static constexpr PinInfo pinInfo { PortAInfo, GPIOA_BasePtr, 0, GPIO_DEFAULT_PCR  };
   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (1 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

};

#define USBDM_GPIOB_IS_DEFINED
/**
 * Peripheral information for GPIO, Digital Input/Output.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioBInfo {
public:
   // Template:gpioa_0x400ff000

   //! Describes the port/gpio
   static constexpr PinInfo pinInfo { PortBInfo, GPIOB_BasePtr, 0, GPIO_DEFAULT_PCR  };
   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

};

#define USBDM_GPIOC_IS_DEFINED
/**
 * Peripheral information for GPIO, Digital Input/Output.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioCInfo {
public:
   // Template:gpioa_0x400ff000

   //! Describes the port/gpio
   static constexpr PinInfo pinInfo { PortCInfo, GPIOC_BasePtr, 0, GPIO_DEFAULT_PCR  };
   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (1 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

};

#define USBDM_GPIOD_IS_DEFINED
/**
 * Peripheral information for GPIO, Digital Input/Output.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioDInfo {
public:
   // Template:gpioa_0x400ff000

   //! Describes the port/gpio
   static constexpr PinInfo pinInfo { PortDInfo, GPIOD_BasePtr, 0, GPIO_DEFAULT_PCR  };
   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (1 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

};

#define USBDM_GPIOE_IS_DEFINED
/**
 * Peripheral information for GPIO, Digital Input/Output.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioEInfo {
public:
   // Template:gpioa_0x400ff000

   //! Describes the port/gpio
   static constexpr PinInfo pinInfo { PortEInfo, GPIOE_BasePtr, 0, GPIO_DEFAULT_PCR  };
   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

};

/**
 * End group GPIO_Group
 * @}
 */
/**
 * @addtogroup I2C_Group I2C, Inter-Integrated-Circuit Interface
 * @brief Abstraction for Inter-Integrated-Circuit Interface
 * @{
 */
#define USBDM_I2C0_IS_DEFINED
/**
 * Peripheral information for I2C, Inter-Integrated-Circuit Interface.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class I2c0Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = I2C0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile I2C_Type &i2c() {
      return *(I2C_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      I2C0_IRQn, };

   // Template:i2c0_f12

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = I2C_DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   /**
    *  Enable clock to I2c0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableI2c0Clock();
#else
      SIM->SCGC4 |= SIM_SCGC4_I2C0_MASK;
#endif
   }

   /**
    *  Disable clock to I2c0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableI2c0Clock();
#else
      SIM->SCGC4 &= ~SIM_SCGC4_I2C0_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: I2C0_SCL             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: I2C0_SDA             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_I2C1_IS_DEFINED
/**
 * Peripheral information for I2C, Inter-Integrated-Circuit Interface.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class I2c1Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = I2C1_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile I2C_Type &i2c() {
      return *(I2C_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      I2C1_IRQn, };

   // Template:i2c0_f12

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = I2C_DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   /**
    *  Enable clock to I2c1
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableI2c1Clock();
#else
      SIM->SCGC4 |= SIM_SCGC4_I2C1_MASK;
#endif
   }

   /**
    *  Disable clock to I2c1
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableI2c1Clock();
#else
      SIM->SCGC4 &= ~SIM_SCGC4_I2C1_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: I2C1_SCL             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: I2C1_SDA             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/**
 * End group I2C_Group
 * @}
 */
/**
 * @addtogroup I2S_Group I2S, Synchronous Audio Interface
 * @brief Abstraction for Synchronous Audio Interface
 * @{
 */
#define USBDM_I2S0_IS_DEFINED
/**
 * Peripheral information for I2S, Synchronous Audio Interface.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class I2s0Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = I2S0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile I2S_Type &i2s() {
      return *(I2S_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      I2S0_Tx_IRQn, I2S0_Rx_IRQn, };

   // Template:i2s0_1ch_1

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = I2C_DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   /**
    *  Enable clock to I2s0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableI2s0Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_I2S_MASK;
#endif
   }

   /**
    *  Disable clock to I2s0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableI2s0Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_I2S_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: I2S0_MCLK            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: I2S0_RX_BCLK         = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: I2S0_RX_FS           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: I2S0_TX_BCLK         = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: I2S0_TX_FS           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: I2S0_TXD0            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   7: I2S0_RXD0            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/**
 * End group I2S_Group
 * @}
 */
/**
 * @addtogroup LLWU_Group LLWU, Low-leakage Wake-up Unit
 * @brief Abstraction for Low-leakage Wake-up Unit
 * @{
 */
#define USBDM_LLWU_IS_DEFINED
/**
 * Peripheral information for LLWU, Low-leakage Wake-up Unit.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class LlwuInfo {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = LLWU_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile LLWU_Type &llwu() {
      return *(LLWU_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      LLWU_IRQn, };

   // Template:llwu_pe4_filt2_mk22f51212

   // Module wake ups
   static constexpr uint8_t me =
      LLWU_ME_WUME0(0) |  // LPTMR
      LLWU_ME_WUME1(0) |  // CMP0
      LLWU_ME_WUME2(0) |  // CMP1
      LLWU_ME_WUME3(0) |  // CMP2/3 (if present)
      LLWU_ME_WUME4(0) |  // TSI0 (if present)
      LLWU_ME_WUME5(0) |  // RTC Alarm
      LLWU_ME_WUME6(0) |  //
      LLWU_ME_WUME7(0);   // RTC Seconds

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   // LLWU Pin Enable registers
   static constexpr uint8_t pe1 =
      LLWU_PE1_WUPE0(0)|   // LLWUP 0
      LLWU_PE1_WUPE1(0)|   // LLWUP 1
      LLWU_PE1_WUPE2(0)|   // LLWUP 2
      LLWU_PE1_WUPE3(0);   // LLWUP 3

   static constexpr uint8_t pe2 =
      LLWU_PE2_WUPE4(0)|   // LLWUP 4
      LLWU_PE2_WUPE5(0)|   // LLWUP 5
      LLWU_PE2_WUPE6(0)|   // LLWUP 6
      LLWU_PE2_WUPE7(0);   // LLWUP 7

   static constexpr uint8_t pe3 =
      LLWU_PE3_WUPE8(0)|   // LLWUP 8
      LLWU_PE3_WUPE9(0)|   // LLWUP 9
      LLWU_PE3_WUPE10(0)|  // LLWUP 10
      LLWU_PE3_WUPE11(0);  // LLWUP 11

   static constexpr uint8_t pe4 =
      LLWU_PE4_WUPE12(0)|  // LLWUP 12
      LLWU_PE4_WUPE13(0)|  // LLWUP 13
      LLWU_PE4_WUPE14(0)|  // LLWUP 14
      LLWU_PE4_WUPE15(0);  // LLWUP 15

   // Pin Filter 1 register
   static constexpr uint8_t filt1 =
      LLWU_FILT_FILTE(0) |   // Digital Filter On External Pin
      LLWU_FILT_FILTSEL(0);  // Filter Pin Select

   // Pin Filter 2 register
   static constexpr uint8_t filt2 =
      LLWU_FILT_FILTE(0) |   // Digital Filter On External Pin
      LLWU_FILT_FILTSEL(0);  // Filter Pin Select

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   //! Number of signals available in info table
   static constexpr int numSignals  = 16;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: LLWU_P0              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: LLWU_P1              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: LLWU_P2              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: LLWU_P3              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: LLWU_P4              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: LLWU_P5              = PTB0 (p35)                     */  { PortBInfo,  GPIOB_BasePtr,  0,       PORT_PCR_MUX(1)|defaultPcrValue  },
         /*   6: LLWU_P6              = PTC1 (p44)                     */  { PortCInfo,  GPIOC_BasePtr,  1,       PORT_PCR_MUX(1)|defaultPcrValue  },
         /*   7: LLWU_P7              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   8: LLWU_P8              = PTC4 (p49)                     */  { PortCInfo,  GPIOC_BasePtr,  4,       PORT_PCR_MUX(1)|defaultPcrValue  },
         /*   9: LLWU_P9              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  10: LLWU_P10             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  11: LLWU_P11             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  12: LLWU_P12             = PTD0 (p57)                     */  { PortDInfo,  GPIOD_BasePtr,  0,       PORT_PCR_MUX(1)|defaultPcrValue  },
         /*  13: LLWU_P13             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  14: LLWU_P14             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  15: LLWU_P15             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
      PCC->PCC_PORTC = PCC_PCCn_CGC_MASK;
      PCC->PCC_PORTD = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTB_CLOCK_MASK|PORTC_CLOCK_MASK|PORTD_CLOCK_MASK);
#endif
      PORTB->GPCLR = pcrValue|PORT_PCR_MUX(1)|PORT_GPCLR_GPWE(0x0001UL);
      PORTC->GPCLR = pcrValue|PORT_PCR_MUX(1)|PORT_GPCLR_GPWE(0x0012UL);
      PORTD->GPCLR = pcrValue|PORT_PCR_MUX(1)|PORT_GPCLR_GPWE(0x0001UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTB = PCC_PCCn_CGC_MASK;
      PCC->PCC_PORTC = PCC_PCCn_CGC_MASK;
      PCC->PCC_PORTD = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTB_CLOCK_MASK|PORTC_CLOCK_MASK|PORTD_CLOCK_MASK);
#endif
      PORTB->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x1U);
      PORTC->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x12U);
      PORTD->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x1U);
   }

};

/**
 * End group LLWU_Group
 * @}
 */
/**
 * @addtogroup LPTMR_Group LPTMR, Low Power Timer
 * @brief Abstraction for Low Power Timer
 * @{
 */
#define USBDM_LPTMR0_IS_DEFINED
/**
 * Peripheral information for LPTMR, Low Power Timer.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Lptmr0Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = LPTMR0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile LPTMR_Type &lptmr() {
      return *(LPTMR_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      LPTMR0_IRQn, };

   // Template:lptmr0

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Default Timer Compare value
   static constexpr uint32_t cmr = 0;

   //! Default PSR value
   static constexpr uint32_t psr =
      LPTMR_PSR_PRESCALE(0)|
      LPTMR_PSR_PBYP(0)|
      LPTMR_PSR_PCS(0);

   //! Default CSR value
   static constexpr uint32_t csr =
      LPTMR_CSR_TIE(0)|
      LPTMR_CSR_TMS(0)|
      LPTMR_CSR_TFC(0)|
      LPTMR_CSR_TPP(0)|
      LPTMR_CSR_TPS(0);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as an uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {

      switch(lptmr().PSR&LPTMR_PSR_PCS_MASK) {
      default:
      case LPTMR_PSR_PCS(0): return McgInfo::getMcgIrClock();
      case LPTMR_PSR_PCS(1): return SystemLpoClock;
      case LPTMR_PSR_PCS(2): return SimInfo::getErc32kClock();
      case LPTMR_PSR_PCS(3): return Osc0Info::getOscerClock();
      }
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a float in Hz
    */
   static float getClockFrequencyF() {

      float freq = getInputClockFrequency();
      if (lptmr().PSR&LPTMR_PSR_PBYP_MASK) {
         return freq;
      }
      return freq/(1<<(((lptmr().PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getClockFrequency() {

      uint32_t freq = getInputClockFrequency();
      if (lptmr().PSR&LPTMR_PSR_PBYP_MASK) {
         return freq;
      }
      return freq/(1<<(((lptmr().PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
   }

   /**
    *  Enable clock to Lptmr0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableLptmr0Clock();
#else
      SIM->SCGC5 |= SIM_SCGC5_LPTMR_MASK;
#endif
   }

   /**
    *  Disable clock to Lptmr0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableLptmr0Clock();
#else
      SIM->SCGC5 &= ~SIM_SCGC5_LPTMR_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 3;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   1: LPTMR0_ALT1          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: LPTMR0_ALT2          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/**
 * End group LPTMR_Group
 * @}
 */
/**
 * @addtogroup LPUART_Group LPUART, Low Power Universal Asynchronous Receiver/Transmitter
 * @brief Abstraction for Low Power Universal Asynchronous Receiver/Transmitter
 * @{
 */
#define USBDM_LPUART0_IS_DEFINED
/**
 * Peripheral information for LPUART, Low Power Universal Asynchronous Receiver/Transmitter.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Lpuart0Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = LPUART0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile LPUART_Type &lpuart() {
      return *(LPUART_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      LPUART0_IRQn, };

   // Template:lpuart0_modir_0x4002a000

   //! Number of samples per bit
   static constexpr uint32_t oversampleRatio = 8;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   //! Default Baud rate used if not explicitly given
   static constexpr uint32_t defaultBaudRate = 115200;

   //! Default buffer size for receive queue when interrupt driven
   static constexpr unsigned receiveBufferSize = 50;

   //! Default buffer size for transmit queue when interrupt driven
   static constexpr unsigned transmitBufferSize = 50;

#if defined(PCC_PCC_LPUART0_CGC_MASK)
   //! Default clock source
   static constexpr PccDiv2Clock defaultClockSource = PccDiv2Clock_Firc;

   /**
    * Set LPUART0 input clock source.
    *
    * @param pccDiv2Clock Clock source selection
    *
    * @note This peripheral uses the DIV2 peripheral clocks e.g. SOSCDIV2_CLK
    * @note The peripheral bus clock will be disabled before changing the
            clock and is left disabled.
    */
   static void setClockSource(PccDiv2Clock pccDiv2Clock) {
      PccInfo::setLpuart0ClockSource(pccDiv2Clock);
   }
#endif

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getClockFrequency() {
#if defined(PCC_PCC_LPUART0_CGC_MASK)
      return PccInfo::getLpuart0Frequency();
   #elif defined(SIM_SOPT2_LPUART0SRC_MASK)
      return SimInfo::getLpuart0Clock();
   #else
      return SimInfo::getLpuartClock();
#endif
   }

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /**
    *  Enable clock to Lpuart0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableLpuart0Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_LPUART0_MASK;
#endif
   }

   /**
    *  Disable clock to Lpuart0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableLpuart0Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_LPUART0_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: LPUART0_TX           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: LPUART0_RX           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: LPUART0_RTS_b        = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: LPUART0_CTS_b        = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/**
 * End group LPUART_Group
 * @}
 */
/**
 * @addtogroup PDB_Group PDB, Programmable Delay Block
 * @brief Abstraction for Programmable Delay Block
 * @{
 */
#define USBDM_PDB0_IS_DEFINED
/**
 * Peripheral information for PDB, Programmable Delay Block.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Pdb0Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = PDB0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile PDB_Type &pdb() {
      return *(PDB_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      PDB0_IRQn, };

   // Template:pdb0_2ch_2pt_2dac_2po

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   static constexpr uint32_t pdb_sc =
      PDB_SC_MULT(0) |      // Multiplication Factor Select for Prescaler
      PDB_SC_PDBIE(0) |     // Interrupt Enable
      PDB_SC_TRGSEL(0) |    // Trigger Input Source Select
      PDB_SC_PRESCALER(0) | // Prescaler Divider Select
      PDB_SC_DMAEN(0) |     // DMA Enable
      PDB_SC_PDBEIE(0) |    // Sequence Error Interrupt Enable
      PDB_SC_LDMOD(0);      // Load Mode Select

   static constexpr uint32_t pdb_mod =
      PDB_MOD_MOD(65535);  // PDB Modulus

   static constexpr uint32_t pdb_idly =
      PDB_IDLY_IDLY(0);  // Counter Modulus

   struct PdbChannel {
      uint32_t c1;
      uint32_t dly0;
      uint32_t dly1;
   };

   // Number of PDB channels
   static constexpr size_t numChannels = 2;

   // Default values for channel registers
   static constexpr PdbChannel pdb_ch[numChannels] = {
   {                   // Channel[0] Control Register 1
      PDB_C1_BB(0x0) |   // Pre-Trigger Back-to-Back Operation Enable
      PDB_C1_TOS(0x0) |  // Pre-Trigger Output Select
      PDB_C1_EN(0x0),    // Pre-Trigger Enable
      PDB_DLY_DLY(0),  // Channel[0] pre-trigger delay 0
      PDB_DLY_DLY(0),  // Channel[0] pre-trigger delay 1
   },
   {                   // Channel[1] Control Register 1
      PDB_C1_BB(0x0) |   // Channel Pre-Trigger Back-to-Back Operation Enable
      PDB_C1_TOS(0x0) |  // Channel Pre-Trigger Output Select
      PDB_C1_EN(0x0),    // Channel Pre-Trigger Enable
      PDB_DLY_DLY(0),  // Channel[1] pre-trigger delay 0
      PDB_DLY_DLY(0),  // Channel[1] pre-trigger delay 1
   },
   };

   struct PdbDac {
      uint32_t dacintc;
      uint32_t dacint;
   };

   // Number of DACs
   static constexpr size_t numDacs = 2;

   // Default values for DAC registers
   static constexpr PdbDac pdb_dac[numDacs] = {
   {                    // DAC[0] Interval register
      PDB_INTC_EXT(0) | // DAC External Trigger Input Enable
      PDB_INTC_TOE(0),  // DAC Interval Trigger Enable
      PDB_INT_INT(0),   // DAC Interval
   },
   {                    // DAC[1] Interval register
      PDB_INTC_EXT(0) | // DAC External Trigger Input Enable
      PDB_INTC_TOE(0),  // DAC Interval Trigger Enable
      PDB_INT_INT(0),   // DAC Interval
   },
   };

   static constexpr uint32_t pdb_poen =
      PDB_POEN_POEN(0x0);   // Pulse-Out Enable

   // Number of PDB pulse outputs
   static constexpr size_t numPulseOutputs = 2;

   static constexpr uint32_t pdb_podly[numPulseOutputs] = {
      // Pulse Output[0] Delays {
      PDB_PODLY_DLY1(0) |  // Delay 1
      PDB_PODLY_DLY2(0),   // Delay 2

      // Pulse Output[1] Delays
      PDB_PODLY_DLY1(0) |  // Delay 1
      PDB_PODLY_DLY2(0),   // Delay 2
   };

   /**
     * Get PDB clock frequency
     *
     * @return Frequency as a uint32_t in Hz
     */
   static __attribute__((always_inline)) uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /**
    *  Enable clock to Pdb0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enablePdb0Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_PDB_MASK;
#endif
   }

   /**
    *  Disable clock to Pdb0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disablePdb0Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_PDB_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: PDB0_EXTRG           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/**
 * End group PDB_Group
 * @}
 */
/**
 * @addtogroup PIT_Group PIT, Programmable Interrupt Timer
 * @brief Abstraction for Programmable Interrupt Timer
 * @{
 */
#define USBDM_PIT_IS_DEFINED
/**
 * Peripheral information for PIT, Programmable Interrupt Timer.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class PitInfo {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = PIT_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile PIT_Type &pit() {
      return *(PIT_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 4;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      PIT0_IRQn, PIT1_IRQn, PIT2_IRQn, PIT3_IRQn, };

   // Template:pit_4ch_chain

   //! Number of PIT channels
   static constexpr uint32_t NumChannels  = 4;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   //! Default value for PIT load value register
   static constexpr uint32_t pit_ldval  = 4799;

   //! PIT operation in debug mode
   static constexpr uint32_t mcr =
      PIT_MCR_FRZ(0) |  // Freeze in debug mode
      PIT_MCR_MDIS(0);  // Disable

   /**
    * Get clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static __attribute__((always_inline)) uint32_t getClockFrequency() {
      return SystemBusClock;
   }

   /**
    *  Enable clock to Pit
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enablePitClock();
#else
      SIM->SCGC6 |= SIM_SCGC6_PIT_MASK;
#endif
   }

   /**
    *  Disable clock to Pit
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disablePitClock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_PIT_MASK;
#endif
   }

};

/**
 * End group PIT_Group
 * @}
 */
/**
 * @addtogroup PMC_Group PMC, Power Management Controller
 * @brief Abstraction for Power Management Controller
 * @{
 */
#define USBDM_PMC_IS_DEFINED
/**
 * Peripheral information for PMC, Power Management Controller.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class PmcInfo {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = PMC_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile PMC_Type &pmc() {
      return *(PMC_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      PMC_IRQn, };

   // Template:pmc_mk

   //! Default value for Low Voltage Detect Status And Control 1 register
   static constexpr uint32_t pmc_lvdsc1  =
   #ifdef PMC_LVDSC1_LVDV
      PMC_LVDSC1_LVDV(0)   | // Low-Voltage Detect Voltage Select
   #endif
      PMC_LVDSC1_LVDIE(0) | // Low-Voltage Detect Interrupt Enable
      PMC_LVDSC1_LVDRE(0);  // Low-Voltage Detect Reset Enable

   //! Default value for Low Voltage Detect Status And Control 2 register
   static constexpr uint32_t pmc_lvdsc2  =
   #ifdef PMC_LVDSC2_LVWV
      PMC_LVDSC2_LVWV(0)   | // Low-Voltage Warning Voltage Select
   #endif
      PMC_LVDSC2_LVWIE(0);  // Low-Voltage Warning Interrupt Enable

   #ifdef PMC_REGSC_BGEN
   //! Default value for Regulator Status And Control register
   static constexpr uint32_t pmc_regsc  =
      PMC_REGSC_BGEN(0) | // Bandgap Enable In VLPx Operation
      PMC_REGSC_BGBE(0);  // Bandgap Buffer Enable

   #endif
   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

};

/**
 * End group PMC_Group
 * @}
 */
/**
 * @addtogroup Power_Group POWER, Power
 * @brief Abstraction for Power
 * @{
 */
#define USBDM_POWER_IS_DEFINED
/**
 * Peripheral information for POWER, Power.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class PowerInfo {
public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 22;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: VBAT                 = VBAT (p21)                     */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*   1: VDD1                 = VDD1 (p3)                      */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*   2: VDD2                 = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: VDD3                 = VDD3 (p30)                     */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*   4: VDD4                 = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: VDD                  = VDD5 (p48)                     */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*   6: VDD6                 = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   7: VDD7                 = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   8: VDDA                 = VDDA (p13)                     */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*   9: VOUT33               = VOUT33 (p7)                    */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*  10: VREFH                = VREFH (p14)                    */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*  11: VREFL                = VREFL (p15)                    */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*  12: VREGIN               = VREGIN (p8)                    */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*  13: VSS1                 = VSS1 (p4)                      */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*  14: VSS1a                = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  15: VSS2                 = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  16: VSS3                 = VSS3 (p31)                     */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*  17: VSS4                 = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  18: VSS                  = VSS5 (p47)                     */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*  19: VSS6                 = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  20: VSS7                 = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  21: VSSA                 = VSSA (p16)                     */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
   };

};

/**
 * End group Power_Group
 * @}
 */
/**
 * @addtogroup RCM_Group RCM, Reset Control Module
 * @brief Abstraction for Reset Control Module
 * @{
 */
#define USBDM_RCM_IS_DEFINED
/**
 * Peripheral information for RCM, Reset Control Module.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class RcmInfo {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = RCM_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile RCM_Type &rcm() {
      return *(RCM_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:rcm_mk_ssrs

   //! Reset Pin Filter Control Register
   static constexpr uint8_t rcm_rpfc =
      RCM_RPFC_RSTFLTSS(0)|   // Reset pin filter select in stop mode
      RCM_RPFC_RSTFLTSRW(0);  // Reset pin filter select in run and wait modes

   //! Reset pin filter bus clock select
   static constexpr uint8_t rcm_rpfw =
      RCM_RPFW_RSTFLTSEL(0);

};

/**
 * End group RCM_Group
 * @}
 */
/**
 * @addtogroup RNGA_Group RNGA, Random Number Generator Accelerator
 * @brief Abstraction for Random Number Generator Accelerator
 * @{
 */
#define USBDM_RNGA_IS_DEFINED
/**
 * Peripheral information for RNGA, Random Number Generator Accelerator.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class RngaInfo {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = RNGA_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile RNGA_Type &rnga() {
      return *(RNGA_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      RNGA_IRQn, };

   // Template:rnga_0x40029000

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /**
    *  Enable clock to Rnga
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableRngaClock();
#else
      SIM->SCGC6 |= SIM_SCGC6_RNGA_MASK;
#endif
   }

   /**
    *  Disable clock to Rnga
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableRngaClock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_RNGA_MASK;
#endif
   }

};

/**
 * End group RNGA_Group
 * @}
 */
/**
 * @addtogroup SMC_Group SMC, System Mode Controller
 * @brief Abstraction for System Mode Controller
 * @{
 */
#define USBDM_SMC_IS_DEFINED
/**
 * Peripheral information for SMC, System Mode Controller.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class SmcInfo {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = SMC_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile SMC_Type &smc() {
      return *(SMC_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:smc_mk22f51212

   // Power Mode Protection Register
   static constexpr uint8_t pmprot =
#ifdef SMC_PMPROT_AHSRUN
      SMC_PMPROT_AHSRUN(1) |  // Allow High Speed Run mode
#endif
      SMC_PMPROT_AVLP(1) |  // Allow very low power modes
      SMC_PMPROT_ALLS(0) |  // Allow low leakage stop mode
      SMC_PMPROT_AVLLS(1);  // Allow very low leakage stop mode

#ifdef SMC_PMCTRL_LPWUI
   // Power Mode Control Register
   static constexpr uint8_t pmctrl =
      SMC_PMCTRL_LPWUI(0);   // Low Power Wake Up on Interrupt

#endif

#ifndef SMC_STOPCTRL_RAM2PO
#define SMC_STOPCTRL_RAM2PO(x) 0
#endif
   // VLLS Control Register
   static constexpr uint8_t stopctrl =
#ifdef SMC_STOPCTRL_PSTOPO
      SMC_STOPCTRL_PSTOPO(0) |  // Partial Stop Option (if present)
#endif

      SMC_STOPCTRL_PORPO(0) |  // POR Power Option
#ifdef SMC_STOPCTRL_LPOPO
      SMC_STOPCTRL_LPOPO(0) |  // POR Power Option (if present)
#endif

      SMC_STOPCTRL_RAM2PO(0) |  // RAM2 Power Option (if present)
      SMC_STOPCTRL_LLSM(0);   // LLS or VLLS Mode Control

};

/**
 * End group SMC_Group
 * @}
 */
/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief Abstraction for Serial Peripheral Interface
 * @{
 */
#define USBDM_SPI0_IS_DEFINED
/**
 * Peripheral information for SPI, Serial Peripheral Interface.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Spi0Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = SPI0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile SPI_Type &spi() {
      return *(SPI_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      SPI0_IRQn, };

   // Template:spi0_mk_pcsis6_pcsse

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /**
    *  Enable clock to Spi0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableSpi0Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_SPI0_MASK;
#endif
   }

   /**
    *  Disable clock to Spi0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableSpi0Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_SPI0_MASK;
#endif
   }

   //! Default communication clock phase and clock polarity (CPHA+CPOL)
   static constexpr uint32_t mode =
      SPI_CTAR_MODE(1);

   //! Default communication order (MSB/LSB first)
   static constexpr uint32_t lsbfe =
      SPI_CTAR_LSBFE(0);

   static uint32_t getClockFrequency() {
      return SystemBusClock;
   }

   //! Default speed (Hz)
   static constexpr uint32_t speed =
      100000;

   //! Number of signals available in info table
   static constexpr int numSignals  = 9;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: SPI0_SCK             = PTC5 (p50)                     */  { PortCInfo,  GPIOC_BasePtr,  5,       PORT_PCR_MUX(2)|defaultPcrValue  },
         /*   1: SPI0_SIN             = PTD3 (p60)                     */  { PortDInfo,  GPIOD_BasePtr,  3,       PORT_PCR_MUX(2)|defaultPcrValue  },
         /*   2: SPI0_SOUT            = PTC6 (p51)                     */  { PortCInfo,  GPIOC_BasePtr,  6,       PORT_PCR_MUX(2)|defaultPcrValue  },
         /*   3: SPI0_PCS0            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: SPI0_PCS1            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: SPI0_PCS2            = PTC2 (p45)                     */  { PortCInfo,  GPIOC_BasePtr,  2,       PORT_PCR_MUX(2)|defaultPcrValue  },
         /*   6: SPI0_PCS3            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   7: SPI0_PCS4            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   8: SPI0_PCS5            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTC = PCC_PCCn_CGC_MASK;
      PCC->PCC_PORTD = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTC_CLOCK_MASK|PORTD_CLOCK_MASK);
#endif
      PORTC->GPCLR = pcrValue|PORT_PCR_MUX(2)|PORT_GPCLR_GPWE(0x0064UL);
      PORTD->GPCLR = pcrValue|PORT_PCR_MUX(2)|PORT_GPCLR_GPWE(0x0008UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTC = PCC_PCCn_CGC_MASK;
      PCC->PCC_PORTD = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTC_CLOCK_MASK|PORTD_CLOCK_MASK);
#endif
      PORTC->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x64U);
      PORTD->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x8U);
   }

};

#define USBDM_SPI1_IS_DEFINED
/**
 * Peripheral information for SPI, Serial Peripheral Interface.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Spi1Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = SPI1_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile SPI_Type &spi() {
      return *(SPI_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      SPI1_IRQn, };

   // Template:spi1_mk_fifo_depth1

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /**
    *  Enable clock to Spi1
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableSpi1Clock();
#else
      SIM->SCGC6 |= SIM_SCGC6_SPI1_MASK;
#endif
   }

   /**
    *  Disable clock to Spi1
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableSpi1Clock();
#else
      SIM->SCGC6 &= ~SIM_SCGC6_SPI1_MASK;
#endif
   }

   //! Default communication clock phase and clock polarity (CPHA+CPOL)
   static constexpr uint32_t mode =
      SPI_CTAR_MODE(1);

   //! Default communication order (MSB/LSB first)
   static constexpr uint32_t lsbfe =
      SPI_CTAR_LSBFE(0);

   static uint32_t getClockFrequency() {
      return SystemBusClock;
   }

   //! Default speed (Hz)
   static constexpr uint32_t speed =
      100000;

   //! Number of signals available in info table
   static constexpr int numSignals  = 7;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: SPI1_SCK             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: SPI1_SIN             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: SPI1_SOUT            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: SPI1_PCS0            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: SPI1_PCS1            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: SPI1_PCS2            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: SPI1_PCS3            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/**
 * End group SPI_Group
 * @}
 */
/**
 * @addtogroup UART_Group UART, Universal Asynchronous Receiver/Transmitter
 * @brief Abstraction for Universal Asynchronous Receiver/Transmitter
 * @{
 */
#define USBDM_UART0_IS_DEFINED
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Uart0Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = UART0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile UART_Type &uart() {
      return *(UART_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      UART0_RxTx_IRQn, UART0_Error_IRQn, };

   // Template:uart0_mk21fa12_c7816

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (1 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /**
    *  Enable clock to Uart0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableUart0Clock();
#else
      SIM->SCGC4 |= SIM_SCGC4_UART0_MASK;
#endif
   }

   /**
    *  Disable clock to Uart0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableUart0Clock();
#else
      SIM->SCGC4 &= ~SIM_SCGC4_UART0_MASK;
#endif
   }

   //! Indicates whether the UART needs a write to clear status errors
   static constexpr bool statusNeedsWrite = false;

   //! Default Baud rate used if not explicitly given
   static constexpr uint32_t defaultBaudRate = 115200;

   //! Default buffer size for receive queue when interrupt driven
   static constexpr unsigned receiveBufferSize = 20;

   //! Default buffer size for transmit queue when interrupt driven
   static constexpr unsigned transmitBufferSize = 100;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static inline uint32_t getInputClockFrequency() {
      return SimInfo::getUart0Clock();
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: UART0_TX             = PTA2 (p24)                     */  { PortAInfo,  GPIOA_BasePtr,  2,       PORT_PCR_MUX(2)|defaultPcrValue  },
         /*   1: UART0_RX             = PTA1 (p23)                     */  { PortAInfo,  GPIOA_BasePtr,  1,       PORT_PCR_MUX(2)|defaultPcrValue  },
         /*   2: UART0_RTS_b          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: UART0_CTS_b          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTA_CLOCK_MASK);
#endif
      PORTA->GPCLR = pcrValue|PORT_PCR_MUX(2)|PORT_GPCLR_GPWE(0x0006UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTA_CLOCK_MASK);
#endif
      PORTA->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x6U);
   }

};

#define USBDM_UART1_IS_DEFINED
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Uart1Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = UART1_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile UART_Type &uart() {
      return *(UART_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      UART1_RxTx_IRQn, UART1_Error_IRQn, };

   // Template:uart1_mk10d10

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (1 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /**
    *  Enable clock to Uart1
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableUart1Clock();
#else
      SIM->SCGC4 |= SIM_SCGC4_UART1_MASK;
#endif
   }

   /**
    *  Disable clock to Uart1
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableUart1Clock();
#else
      SIM->SCGC4 &= ~SIM_SCGC4_UART1_MASK;
#endif
   }

   //! Indicates whether the UART needs a write to clear status errors
   static constexpr bool statusNeedsWrite = false;

   //! Default Baud rate used if not explicitly given
   static constexpr uint32_t defaultBaudRate = 115200;

   //! Default buffer size for receive queue when interrupt driven
   static constexpr unsigned receiveBufferSize = 50;

   //! Default buffer size for transmit queue when interrupt driven
   static constexpr unsigned transmitBufferSize = 50;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static inline uint32_t getInputClockFrequency() {
      return SimInfo::getUart1Clock();
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: UART1_TX             = PTE0 (p1)                      */  { PortEInfo,  GPIOE_BasePtr,  0,       PORT_PCR_MUX(3)|defaultPcrValue  },
         /*   1: UART1_RX             = PTE1 (p2)                      */  { PortEInfo,  GPIOE_BasePtr,  1,       PORT_PCR_MUX(3)|defaultPcrValue  },
         /*   2: UART1_RTS_b          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: UART1_CTS_b          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTE = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTE_CLOCK_MASK);
#endif
      PORTE->GPCLR = pcrValue|PORT_PCR_MUX(3)|PORT_GPCLR_GPWE(0x0003UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTE = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTE_CLOCK_MASK);
#endif
      PORTE->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x3U);
   }

};

#define USBDM_UART2_IS_DEFINED
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Uart2Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = UART2_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile UART_Type &uart() {
      return *(UART_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      UART2_RxTx_IRQn, UART2_Error_IRQn, };

   // Template:uart1_mk10d10

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

   /**
    *  Enable clock to Uart2
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableUart2Clock();
#else
      SIM->SCGC4 |= SIM_SCGC4_UART2_MASK;
#endif
   }

   /**
    *  Disable clock to Uart2
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableUart2Clock();
#else
      SIM->SCGC4 &= ~SIM_SCGC4_UART2_MASK;
#endif
   }

   //! Indicates whether the UART needs a write to clear status errors
   static constexpr bool statusNeedsWrite = false;

   //! Default Baud rate used if not explicitly given
   static constexpr uint32_t defaultBaudRate = 115200;

   //! Default buffer size for receive queue when interrupt driven
   static constexpr unsigned receiveBufferSize = 50;

   //! Default buffer size for transmit queue when interrupt driven
   static constexpr unsigned transmitBufferSize = 50;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static inline uint32_t getInputClockFrequency() {
      return SimInfo::getUart2Clock();
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: UART2_TX             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: UART2_RX             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: UART2_RTS_b          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: UART2_CTS_b          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/**
 * End group UART_Group
 * @}
 */
/**
 * @addtogroup USB_Group USB, USB OTG Controller
 * @brief Abstraction for USB OTG Controller
 * @{
 */
#define USBDM_USB0_IS_DEFINED
/**
 * Peripheral information for USB, USB OTG Controller.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Usb0Info {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = USB0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile USB_Type &usb() {
      return *(USB_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      USB0_IRQn, };

   // Template:usb0_otg_clkrcv_c

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   // Enable IRC Clock
   static constexpr uint32_t clk_recovery_irc_en =
   #ifdef USB_CLK_RECOVER_IRC_EN_REG_EN
         USB_CLK_RECOVER_IRC_EN_REG_EN(1)|  // Enable power regulator
   #endif
         USB_CLK_RECOVER_IRC_EN_IRC_EN(1);  // Enable

   // Clock recovery options
   static constexpr uint32_t clk_recovery_ctrl =
         USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(1)|       // Enable clock recovery
         USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(1)|  // Go to rough mode when reset/resumed
         USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(1);     // Always use trim value as starting point

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 1;

   //! Default IRQ level
   static constexpr uint32_t irqLevel = 8;

   /**
    *  Enable clock to Usb0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableUsb0Clock();
#else
      SIM->SCGC4 |= SIM_SCGC4_USBOTG_MASK;
#endif
   }

   /**
    *  Disable clock to Usb0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableUsb0Clock();
#else
      SIM->SCGC4 &= ~SIM_SCGC4_USBOTG_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: USB0_DM              = USB0_DM (p6)                   */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*   1: USB0_DP              = USB0_DP (p5)                   */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
         /*   2: USB_CLKIN            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: USB_SOF_OUT          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/**
 * End group USB_Group
 * @}
 */
/**
 * @addtogroup VREF_Group VREF, Voltage Reference
 * @brief Abstraction for Voltage Reference
 * @{
 */
#define USBDM_VREF_IS_DEFINED
/**
 * Peripheral information for VREF, Voltage Reference.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class VrefInfo {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = VREF_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile VREF_Type &vref() {
      return *(VREF_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:vref_c

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   static constexpr uint8_t vref_trm =
       VREF_TRM_CHOPEN(1) | // Chop oscillator enable
       VREF_TRM_TRIM(32);   // Trim bits

   static constexpr uint8_t vref_sc =
       VREF_SC_VREFEN(1) |   // Internal Voltage Reference enable
       VREF_SC_REGEN(1) |    // Regulator enable
       VREF_SC_ICOMPEN(1) |  // Second order curvature compensation enable
       VREF_SC_MODE_LV(1);   // Buffer Mode selection

   /**
    *  Enable clock to Vref
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableVrefClock();
#else
      SIM->SCGC4 |= SIM_SCGC4_VREF_MASK;
#endif
   }

   /**
    *  Disable clock to Vref
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableVrefClock();
#else
      SIM->SCGC4 &= ~SIM_SCGC4_VREF_MASK;
#endif
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: VREF_OUT             = VREF_OUT (p17)                 */  { NoPortInfo, 0,         FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/**
 * End group VREF_Group
 * @}
 */
/**
 * @addtogroup WDOG_Group WDOG, Watchdog Timer
 * @brief Abstraction for Watchdog Timer
 * @{
 */
#define USBDM_WDOG_IS_DEFINED
/**
 * Peripheral information for WDOG, Watchdog Timer.
 *
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class WdogInfo {
public:
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = WDOG_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile WDOG_Type &wdog() {
      return *(WDOG_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      WDOG_IRQn, };

   // Template:wdog_mk

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = 0;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  8;

};

/**
 * End group WDOG_Group
 * @}
 */
/**
 * End group USBDM_Group
 * @}
 */

} // End namespace USBDM


#include "adc.h"
#include "ftm.h"
#include "gpio.h"

/**
 * Namespace enclosing USBDM classes
 */
namespace USBDM {

/**
 * @addtogroup USBDM_Group USBDM Peripheral Interface
 * @brief Hardware Peripheral Interface and library
 * @{
 */
/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Abstraction for Analogue Input
 * @{
 */
using Adc_p10              = const USBDM::Adc0Channel<19>;
using Adc_p9               = const USBDM::Adc0Channel<0>;
using Adc_p11              = const USBDM::Adc0Channel<3>;
using Adc_p18              = const USBDM::Adc0Channel<23>;
using Adc_p37              = const USBDM::Adc0Channel<12>;
using Adc_p12              = const USBDM::Adc1Channel<19>;
//using Adc_p11              = const USBDM::Adc1Channel<0>;
using Adc_p17              = const USBDM::Adc1Channel<18>;
/**
 * End group ADC_Group
 * @}
 */
/**
 * @addtogroup FTM_Group FTM, PWM, Input capture and Output compare
 * @brief Abstraction for PWM, Input capture and Output compare
 * @{
 */
using Ftm_p46              = const USBDM::Ftm0Channel<2>;
using Ftm_p61              = const USBDM::Ftm0Channel<4>;
using Ftm_p63              = const USBDM::Ftm0Channel<6>;
/**
 * End group FTM_Group
 * @}
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Abstraction for Digital Input/Output
 * @{
 */
using Gpio_p35             = const USBDM::GpioB<0>;
using Gpio_p38             = const USBDM::GpioB<3>;
using Gpio_p43             = const USBDM::GpioC<0>;
using Gpio_p44             = const USBDM::GpioC<1>;
using Gpio_p49             = const USBDM::GpioC<4>;
using Gpio_p57             = const USBDM::GpioD<0>;
using Gpio_p58             = const USBDM::GpioD<1>;
using Gpio_p64             = const USBDM::GpioD<7>;
/**
 * End group GPIO_Group
 * @}
 */
/**
 * End group USBDM_Group
 * @}
 */

} // End namespace USBDM

/**
 *
 * @page PinSummary Pin Mapping
 *
 * @section PinsByPinName Pins by Pin Name
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description
 *  ------------------------ | --------------------------------------------|---------------------------| -------------
 *  ADC0_DM0                 | ADC0_DM0/ADC1_DM3/ADC0_SE19                 | p10                       | Id
 *  ADC0_DP0                 | ADC0_DP0/ADC1_DP3/ADC0_SE0                  | p9                        | N/C
 *  ADC1_DM0                 | ADC1_DM0/ADC0_DM3/ADC1_SE19                 | p12                       | N/C
 *  ADC1_DP0                 | ADC1_DP0/ADC0_DP3/ADC1_SE0/ADC0_SE3         | p11                       | N/C
 *  DAC0_OUT                 | DAC0_OUT/CMP1_IN3/ADC0_SE23                 | p18                       | N/C
 *  EXTAL32                  | EXTAL32                                     | p20                       | N/C
 *  PTA0                     | JTAG_TCLK/SWD_CLK                           | p22                       | SWD_CLK
 *  PTA1                     | UART0_RX                                    | p23                       | Console_Rx
 *  PTA2                     | UART0_TX                                    | p24                       | Console_Tx
 *  PTA3                     | JTAG_TMS/SWD_DIO                            | p25                       | SWD_DIO
 *  PTA4                     | -                                           | p26                       | N/C
 *  PTA5                     | -                                           | p27                       | N/C
 *  PTA12                    | -                                           | p28                       | N/C
 *  PTA13                    | -                                           | p29                       | N/C
 *  PTA18                    | -                                           | p32                       | N/C
 *  PTA19                    | -                                           | p33                       | N/C
 *  PTB0                     | GPIOB_0/LLWU_P5                             | p35                       | TPa
 *  PTB1                     | -                                           | p36                       | TPa
 *  PTB2                     | ADC0_SE12                                   | p37                       | Vbdm
 *  PTB3                     | GPIOB_3                                     | p38                       | PWR_LED
 *  PTB16                    | -                                           | p39                       | N/C
 *  PTB17                    | -                                           | p40                       | N/C
 *  PTB18                    | -                                           | p41                       | N/C
 *  PTB19                    | -                                           | p42                       | N/C
 *  PTC0                     | GPIOC_0                                     | p43                       | RST_DIR
 *  PTC1                     | GPIOC_1/LLWU_P6                             | p44                       | RST_IO
 *  PTC2                     | SPI0_PCS2                                   | p45                       | BKGD/SWD_DIR
 *  PTC3                     | FTM0_CH2                                    | p46                       | BKGD/SWD_DIR
 *  PTC4                     | GPIOC_4/LLWU_P8                             | p49                       | SWD_EN
 *  PTC5                     | SPI0_SCK                                    | p50                       | SWCLK_O
 *  PTC6                     | SPI0_SOUT                                   | p51                       | BKGD/SWD_O
 *  PTC7                     | CMP0_IN1                                    | p52                       | Vbdm
 *  PTC8                     | -                                           | p53                       | N/C
 *  PTC9                     | -                                           | p54                       | N/C
 *  PTC10                    | -                                           | p55                       | N/C
 *  PTC11                    | -                                           | p56                       | N/C
 *  PTD0                     | GPIOD_0/LLWU_P12                            | p57                       | VDD_FAULT
 *  PTD1                     | GPIOD_1                                     | p58                       | VDD_EN
 *  PTD2                     | -                                           | p59                       | N/C
 *  PTD3                     | SPI0_SIN                                    | p60                       | BKGD/SWD_I
 *  PTD4                     | FTM0_CH4                                    | p61                       | BKGD/SWD_I
 *  PTD5                     | -                                           | p62                       | N/C
 *  PTD6                     | FTM0_CH6                                    | p63                       | BKGD/SWD_O
 *  PTD7                     | GPIOD_7                                     | p64                       | USB_LED
 *  PTE0                     | UART1_TX                                    | p1                        | DBG_Tx
 *  PTE1                     | UART1_RX                                    | p2                        | DBG_Rx
 *  RESET_b                  | RESET_b                                     | p34                       | Resetb
 *  USB0_DM                  | USB0_DM                                     | p6                        | USB_DM
 *  USB0_DP                  | USB0_DP                                     | p5                        | USB_DP
 *  VBAT                     | VBAT                                        | p21                       | 3V3
 *  VDD1                     | VDD1                                        | p3                        | 3V3
 *  VDD3                     | VDD3                                        | p30                       | 3V3
 *  VDD5                     | VDD                                         | p48                       | 3V3
 *  VDDA                     | VDDA                                        | p13                       | 3V3
 *  VOUT33                   | VOUT33                                      | p7                        | 3V3
 *  VREFH                    | VREFH                                       | p14                       | 3V3
 *  VREFL                    | VREFL                                       | p15                       | -
 *  VREF_OUT                 | VREF_OUT/CMP1_IN5/CMP0_IN5/ADC1_SE18        | p17                       | N/C
 *  VREGIN                   | VREGIN                                      | p8                        | 5V
 *  VSS1                     | VSS1                                        | p4                        | Vss
 *  VSS3                     | VSS3                                        | p31                       | Vss
 *  VSS5                     | VSS                                         | p47                       | Vss
 *  VSSA                     | VSSA                                        | p16                       | Vss
 *  XTAL32                   | XTAL32                                      | p19                       | N/C
 *
 *
 * @section PinsByLocation Pins by Location
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description
 *  ------------------------ | --------------------------------------------|---------------------------| -------------
 *  PTE0                     | UART1_TX                                    | p1                        | DBG_Tx
 *  PTE1                     | UART1_RX                                    | p2                        | DBG_Rx
 *  VDD1                     | VDD1                                        | p3                        | 3V3
 *  VSS1                     | VSS1                                        | p4                        | Vss
 *  USB0_DP                  | USB0_DP                                     | p5                        | USB_DP
 *  USB0_DM                  | USB0_DM                                     | p6                        | USB_DM
 *  VOUT33                   | VOUT33                                      | p7                        | 3V3
 *  VREGIN                   | VREGIN                                      | p8                        | 5V
 *  ADC0_DP0                 | ADC0_DP0/ADC1_DP3/ADC0_SE0                  | p9                        | N/C
 *  ADC0_DM0                 | ADC0_DM0/ADC1_DM3/ADC0_SE19                 | p10                       | Id
 *  ADC1_DP0                 | ADC1_DP0/ADC0_DP3/ADC1_SE0/ADC0_SE3         | p11                       | N/C
 *  ADC1_DM0                 | ADC1_DM0/ADC0_DM3/ADC1_SE19                 | p12                       | N/C
 *  VDDA                     | VDDA                                        | p13                       | 3V3
 *  VREFH                    | VREFH                                       | p14                       | 3V3
 *  VREFL                    | VREFL                                       | p15                       | -
 *  VSSA                     | VSSA                                        | p16                       | Vss
 *  VREF_OUT                 | VREF_OUT/CMP1_IN5/CMP0_IN5/ADC1_SE18        | p17                       | N/C
 *  DAC0_OUT                 | DAC0_OUT/CMP1_IN3/ADC0_SE23                 | p18                       | N/C
 *  XTAL32                   | XTAL32                                      | p19                       | N/C
 *  EXTAL32                  | EXTAL32                                     | p20                       | N/C
 *  VBAT                     | VBAT                                        | p21                       | 3V3
 *  PTA0                     | JTAG_TCLK/SWD_CLK                           | p22                       | SWD_CLK
 *  PTA1                     | UART0_RX                                    | p23                       | Console_Rx
 *  PTA2                     | UART0_TX                                    | p24                       | Console_Tx
 *  PTA3                     | JTAG_TMS/SWD_DIO                            | p25                       | SWD_DIO
 *  PTA4                     | -                                           | p26                       | N/C
 *  PTA5                     | -                                           | p27                       | N/C
 *  PTA12                    | -                                           | p28                       | N/C
 *  PTA13                    | -                                           | p29                       | N/C
 *  VDD3                     | VDD3                                        | p30                       | 3V3
 *  VSS3                     | VSS3                                        | p31                       | Vss
 *  PTA18                    | -                                           | p32                       | N/C
 *  PTA19                    | -                                           | p33                       | N/C
 *  RESET_b                  | RESET_b                                     | p34                       | Resetb
 *  PTB0                     | GPIOB_0/LLWU_P5                             | p35                       | TPa
 *  PTB1                     | -                                           | p36                       | TPa
 *  PTB2                     | ADC0_SE12                                   | p37                       | Vbdm
 *  PTB3                     | GPIOB_3                                     | p38                       | PWR_LED
 *  PTB16                    | -                                           | p39                       | N/C
 *  PTB17                    | -                                           | p40                       | N/C
 *  PTB18                    | -                                           | p41                       | N/C
 *  PTB19                    | -                                           | p42                       | N/C
 *  PTC0                     | GPIOC_0                                     | p43                       | RST_DIR
 *  PTC1                     | GPIOC_1/LLWU_P6                             | p44                       | RST_IO
 *  PTC2                     | SPI0_PCS2                                   | p45                       | BKGD/SWD_DIR
 *  PTC3                     | FTM0_CH2                                    | p46                       | BKGD/SWD_DIR
 *  VSS5                     | VSS                                         | p47                       | Vss
 *  VDD5                     | VDD                                         | p48                       | 3V3
 *  PTC4                     | GPIOC_4/LLWU_P8                             | p49                       | SWD_EN
 *  PTC5                     | SPI0_SCK                                    | p50                       | SWCLK_O
 *  PTC6                     | SPI0_SOUT                                   | p51                       | BKGD/SWD_O
 *  PTC7                     | CMP0_IN1                                    | p52                       | Vbdm
 *  PTC8                     | -                                           | p53                       | N/C
 *  PTC9                     | -                                           | p54                       | N/C
 *  PTC10                    | -                                           | p55                       | N/C
 *  PTC11                    | -                                           | p56                       | N/C
 *  PTD0                     | GPIOD_0/LLWU_P12                            | p57                       | VDD_FAULT
 *  PTD1                     | GPIOD_1                                     | p58                       | VDD_EN
 *  PTD2                     | -                                           | p59                       | N/C
 *  PTD3                     | SPI0_SIN                                    | p60                       | BKGD/SWD_I
 *  PTD4                     | FTM0_CH4                                    | p61                       | BKGD/SWD_I
 *  PTD5                     | -                                           | p62                       | N/C
 *  PTD6                     | FTM0_CH6                                    | p63                       | BKGD/SWD_O
 *  PTD7                     | GPIOD_7                                     | p64                       | USB_LED
 *
 *
 * @section PinsByFunction Pins by Function
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description
 *  ------------------------ | --------------------------------------------|---------------------------| -------------
 *  PTD5                     | -                                           | p62                       | N/C
 *  ADC0_DM0                 | ADC0_DM0/ADC1_DM3/ADC0_SE19                 | p10                       | Id
 *  ADC0_DP0                 | ADC0_DP0/ADC1_DP3/ADC0_SE0                  | p9                        | N/C
 *  PTB2                     | ADC0_SE12                                   | p37                       | Vbdm
 *  ADC1_DM0                 | ADC1_DM0/ADC0_DM3/ADC1_SE19                 | p12                       | N/C
 *  ADC1_DP0                 | ADC1_DP0/ADC0_DP3/ADC1_SE0/ADC0_SE3         | p11                       | N/C
 *  PTC7                     | CMP0_IN1                                    | p52                       | Vbdm
 *  DAC0_OUT                 | DAC0_OUT/CMP1_IN3/ADC0_SE23                 | p18                       | N/C
 *  EXTAL32                  | EXTAL32                                     | p20                       | N/C
 *  PTC3                     | FTM0_CH2                                    | p46                       | BKGD/SWD_DIR
 *  PTD4                     | FTM0_CH4                                    | p61                       | BKGD/SWD_I
 *  PTD6                     | FTM0_CH6                                    | p63                       | BKGD/SWD_O
 *  PTB0                     | GPIOB_0/LLWU_P5                             | p35                       | TPa
 *  PTB3                     | GPIOB_3                                     | p38                       | PWR_LED
 *  PTC0                     | GPIOC_0                                     | p43                       | RST_DIR
 *  PTC1                     | GPIOC_1/LLWU_P6                             | p44                       | RST_IO
 *  PTC4                     | GPIOC_4/LLWU_P8                             | p49                       | SWD_EN
 *  PTD0                     | GPIOD_0/LLWU_P12                            | p57                       | VDD_FAULT
 *  PTD1                     | GPIOD_1                                     | p58                       | VDD_EN
 *  PTD7                     | GPIOD_7                                     | p64                       | USB_LED
 *  PTA0                     | JTAG_TCLK/SWD_CLK                           | p22                       | SWD_CLK
 *  PTA3                     | JTAG_TMS/SWD_DIO                            | p25                       | SWD_DIO
 *  RESET_b                  | RESET_b                                     | p34                       | Resetb
 *  PTC2                     | SPI0_PCS2                                   | p45                       | BKGD/SWD_DIR
 *  PTC5                     | SPI0_SCK                                    | p50                       | SWCLK_O
 *  PTD3                     | SPI0_SIN                                    | p60                       | BKGD/SWD_I
 *  PTC6                     | SPI0_SOUT                                   | p51                       | BKGD/SWD_O
 *  PTA1                     | UART0_RX                                    | p23                       | Console_Rx
 *  PTA2                     | UART0_TX                                    | p24                       | Console_Tx
 *  PTE1                     | UART1_RX                                    | p2                        | DBG_Rx
 *  PTE0                     | UART1_TX                                    | p1                        | DBG_Tx
 *  USB0_DM                  | USB0_DM                                     | p6                        | USB_DM
 *  USB0_DP                  | USB0_DP                                     | p5                        | USB_DP
 *  VBAT                     | VBAT                                        | p21                       | 3V3
 *  VDD5                     | VDD                                         | p48                       | 3V3
 *  VDD1                     | VDD1                                        | p3                        | 3V3
 *  VDD3                     | VDD3                                        | p30                       | 3V3
 *  VDDA                     | VDDA                                        | p13                       | 3V3
 *  VOUT33                   | VOUT33                                      | p7                        | 3V3
 *  VREFH                    | VREFH                                       | p14                       | 3V3
 *  VREFL                    | VREFL                                       | p15                       | -
 *  VREF_OUT                 | VREF_OUT/CMP1_IN5/CMP0_IN5/ADC1_SE18        | p17                       | N/C
 *  VREGIN                   | VREGIN                                      | p8                        | 5V
 *  VSS5                     | VSS                                         | p47                       | Vss
 *  VSS1                     | VSS1                                        | p4                        | Vss
 *  VSS3                     | VSS3                                        | p31                       | Vss
 *  VSSA                     | VSSA                                        | p16                       | Vss
 *  XTAL32                   | XTAL32                                      | p19                       | N/C
 *
 */

#endif /* PROJECT_HEADERS_PIN_MAPPING_H */
